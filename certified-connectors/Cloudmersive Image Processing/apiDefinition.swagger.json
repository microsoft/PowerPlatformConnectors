{
  "definitions": {
    "AgeDetectionResult": {
      "description": "Result from classifying the Age of people in an image",
      "properties": {
        "PeopleIdentified": {
          "description": "Number of people identified in the image with an age",
          "format": "int32",
          "type": "integer"
        },
        "PeopleWithAge": {
          "description": "People in the image annotated with age information",
          "items": {
            "$ref": "#/definitions/PersonWithAge"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ColorResult": {
      "description": "Individual color",
      "properties": {
        "B": {
          "description": "Blue (B) channel pixel value of this color",
          "format": "int32",
          "type": "integer"
        },
        "G": {
          "description": "Green (G) channel pixel value of this color",
          "format": "int32",
          "type": "integer"
        },
        "R": {
          "description": "Red (R) channel pixel value of this color",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DetectedLicensePlate": {
      "description": "License plate found in the image",
      "properties": {
        "Height": {
          "description": "Height of the license plate's location in pixels",
          "format": "int32",
          "type": "integer"
        },
        "LicensePlateRecognitionConfidenceLevel": {
          "description": "Confidence score on a range of 0.0 - 1.0 of the accuracy of the detected license plate, with higher scores being better; values about 0.75 are high confidence",
          "format": "double",
          "type": "number"
        },
        "LicensePlateText_BestMatch": {
          "description": "Text from the license plate, highest-confidence result",
          "type": "string"
        },
        "LicensePlateText_RunnerUp": {
          "description": "Alternate text from the license plate, based on second-highest-confidence result",
          "type": "string"
        },
        "LocationX": {
          "description": "X location of the left edge of the license plate, starting from the left edge of the photo (X = 0)",
          "format": "int32",
          "type": "integer"
        },
        "LocationY": {
          "description": "Y location of the top edge of the license plate, starting from the top edge of the photo (Y = 0)",
          "format": "int32",
          "type": "integer"
        },
        "Width": {
          "description": "Width of the license plate's location in pixels",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DetectedObject": {
      "description": "Single object instance, and associated details, detected in an image",
      "properties": {
        "Height": {
          "description": "Height, in pixels, of the object",
          "format": "int32",
          "type": "integer"
        },
        "ObjectClassName": {
          "description": "Class of the object.  Example values are \"person\", \"car\", \"dining table\", etc.",
          "type": "string"
        },
        "Score": {
          "description": "Confidence score of detected object; possible values are between 0.0 and 1.0; values closer to 1.0 are higher confidence",
          "format": "double",
          "type": "number"
        },
        "Width": {
          "description": "Width, in pixels, of the object",
          "format": "int32",
          "type": "integer"
        },
        "X": {
          "description": "X location, in pixels, of the left side location of the object, with the right side being X + Width",
          "format": "int32",
          "type": "integer"
        },
        "Y": {
          "description": "Y location, in pixels, of the top side location of the object, with the bottom side being Y + Height",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DominantColorResult": {
      "description": "Result of performing a get dominant color operation",
      "properties": {
        "DominantColors": {
          "description": "Dominant colors in the image, in order where most dominant color is in the first index position (0), the second most-dominant color is in index position 1 and so on",
          "items": {
            "$ref": "#/definitions/ColorResult"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DrawPolygonInstance": {
      "description": "Polygon instance to draw on an image",
      "properties": {
        "BorderColor": {
          "description": "Border Color to use - can be a hex value (with #) or HTML common color name.  Transparent colors are supported.",
          "type": "string"
        },
        "BorderWidth": {
          "description": "Width in pixels of the border.  Pass in 0 to draw a polygon with no border",
          "format": "double",
          "type": "number"
        },
        "FillColor": {
          "description": "Fill Color to use - can be a hex value (with #) or HTML common color name.  Transparent colors are supported.  Leave blank to not fill the polygon.",
          "type": "string"
        },
        "Points": {
          "description": "Points (vertices) which comprise the polygon; valid polygons must have at least 3 points",
          "items": {
            "$ref": "#/definitions/PolygonPoint"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DrawPolygonRequest": {
      "description": "Request to draw one or more polygons on a base image",
      "properties": {
        "BaseImageBytes": {
          "description": "Image to draw polygons on, in bytes.  You can also use the BaseImageUrl instead to supply image input as a URL",
          "format": "byte",
          "type": "string"
        },
        "BaseImageUrl": {
          "description": "Image to draw polygons on, as an HTTP or HTTPS fully-qualified URL",
          "type": "string"
        },
        "PolygonsToDraw": {
          "description": "Polygons to draw on the image.  Polygons are drawn in index order.",
          "items": {
            "$ref": "#/definitions/DrawPolygonInstance"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DrawRectangleInstance": {
      "description": "Rectangle instance to draw on an image",
      "properties": {
        "BorderColor": {
          "description": "Border Color to use - can be a hex value (with #) or HTML common color name.  Transparent colors are supported.",
          "type": "string"
        },
        "BorderWidth": {
          "description": "Width in pixels of the border.  Pass in 0 to draw a rectangle with no border",
          "format": "double",
          "type": "number"
        },
        "FillColor": {
          "description": "Fill Color to use - can be a hex value (with #) or HTML common color name.  Transparent colors are supported.  Leave blank to not fill the rectangle.",
          "type": "string"
        },
        "Height": {
          "description": "Height in pixels of the rectangle",
          "format": "double",
          "type": "number"
        },
        "Width": {
          "description": "Width in pixels of the rectangle",
          "format": "double",
          "type": "number"
        },
        "X": {
          "description": "Pixel location of the left edge of the rectangle location",
          "format": "double",
          "type": "number"
        },
        "Y": {
          "description": "Pixel location of the top edge of the rectangle location",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "DrawRectangleRequest": {
      "description": "Request to draw one or more rectangles on a base image",
      "properties": {
        "BaseImageBytes": {
          "description": "Image to draw rectangles on, in bytes.  You can also use the BaseImageUrl instead to supply image input as a URL",
          "format": "byte",
          "type": "string"
        },
        "BaseImageUrl": {
          "description": "Image to draw rectangles on, as an HTTP or HTTPS fully-qualified URL",
          "type": "string"
        },
        "RectanglesToDraw": {
          "description": "Rectangles to draw on the image.  Rectangles are drawn in index order.",
          "items": {
            "$ref": "#/definitions/DrawRectangleInstance"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DrawTextInstance": {
      "description": "Text instance to draw on an image",
      "properties": {
        "Color": {
          "description": "Color to use - can be a hex value (with #) or HTML common color name",
          "type": "string"
        },
        "FontFamilyName": {
          "description": "Font Family to use.  Leave blank to default to \"Arial\".",
          "type": "string"
        },
        "FontSize": {
          "description": "Font size to use.",
          "format": "double",
          "type": "number"
        },
        "Height": {
          "description": "Height in pixels of the text box to draw the text in; text will wrap inside this box",
          "format": "double",
          "type": "number"
        },
        "Text": {
          "description": "Text string to draw",
          "type": "string"
        },
        "Width": {
          "description": "Width in pixels of the text box to draw the text in; text will wrap inside this box",
          "format": "double",
          "type": "number"
        },
        "X": {
          "description": "Pixel location of the left edge of the text location",
          "format": "double",
          "type": "number"
        },
        "Y": {
          "description": "Pixel location of the top edge of the text location",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "DrawTextRequest": {
      "description": "Request to draw one or more pieces of text onto an image",
      "properties": {
        "BaseImageBytes": {
          "description": "Image to draw text on, in bytes.  You can also use the BaseImageUrl instead to supply image input as a URL",
          "format": "byte",
          "type": "string"
        },
        "BaseImageUrl": {
          "description": "Image to draw text on, as an HTTP or HTTPS fully-qualified URL",
          "type": "string"
        },
        "TextToDraw": {
          "description": "One or more pieces of text to draw onto the image",
          "items": {
            "$ref": "#/definitions/DrawTextInstance"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "Face": {
      "description": "Location of one face in an image",
      "properties": {
        "BottomY": {
          "description": "Y coordinate of the bottom side of the face",
          "format": "int32",
          "type": "integer"
        },
        "LeftX": {
          "description": "X coordinate of the left side of the face",
          "format": "int32",
          "type": "integer"
        },
        "RightX": {
          "description": "X coordinate of the right side of the face",
          "format": "int32",
          "type": "integer"
        },
        "TopY": {
          "description": "Y coordinate of the top side of the face",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "FaceCompareResponse": {
      "description": "Results of comparing/matching faces in an image",
      "properties": {
        "ErrorDetails": {
          "description": "Details of any errors that occurred",
          "type": "string"
        },
        "FaceCount": {
          "description": "Number of faces found in the image",
          "format": "int32",
          "type": "integer"
        },
        "Faces": {
          "description": "Array of faces found in the input image",
          "items": {
            "$ref": "#/definitions/FaceMatch"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "FaceLocateResponse": {
      "description": "Results of locating faces in an image",
      "properties": {
        "ErrorDetails": {
          "description": "Details of any errors that occurred",
          "type": "string"
        },
        "FaceCount": {
          "description": "Number of faces found in the image",
          "format": "int32",
          "type": "integer"
        },
        "Faces": {
          "description": "Array of faces found in the image",
          "items": {
            "$ref": "#/definitions/Face"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "FaceLocateWithLandmarksResponse": {
      "description": "Results of locating faces in an image",
      "properties": {
        "ErrorDetails": {
          "description": "Details of any errors that occurred",
          "type": "string"
        },
        "FaceCount": {
          "description": "Number of faces found in the image",
          "format": "int32",
          "type": "integer"
        },
        "Faces": {
          "description": "Array of faces found in the image",
          "items": {
            "$ref": "#/definitions/FaceWithLandmarks"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "FaceMatch": {
      "description": "Location of one face in an image, along with match results",
      "properties": {
        "BottomY": {
          "description": "Y coordinate of the bottom side of the face",
          "format": "int32",
          "type": "integer"
        },
        "HighConfidenceMatch": {
          "description": "True if there is a high confidence match, false otherwise",
          "type": "boolean"
        },
        "LeftX": {
          "description": "X coordinate of the left side of the face",
          "format": "int32",
          "type": "integer"
        },
        "MatchScore": {
          "description": "Match score from 0.0 to 1.0 with higher scores indicating a greater match; scores above 0.7 indicate a match",
          "format": "double",
          "type": "number"
        },
        "RightX": {
          "description": "X coordinate of the right side of the face",
          "format": "int32",
          "type": "integer"
        },
        "TopY": {
          "description": "Y coordinate of the top side of the face",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "FacePoint": {
      "description": "Point location within a face",
      "properties": {
        "X": {
          "description": "X location, where 0 is the left-most pixel",
          "format": "int32",
          "type": "integer"
        },
        "Y": {
          "description": "Y location, where 0 is the top-most pixel",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "FaceWithLandmarks": {
      "description": "Location of one face in an image",
      "properties": {
        "BottomAndSidesOfFace": {
          "description": "Point locations of the bottom and sides of the face (cheeks and chin)",
          "items": {
            "$ref": "#/definitions/FacePoint"
          },
          "type": "array"
        },
        "BottomY": {
          "description": "Y coordinate of the bottom side of the face",
          "format": "int32",
          "type": "integer"
        },
        "LeftEye": {
          "description": "Point locations of the left eye (the eye closest to the left side of the picture)",
          "items": {
            "$ref": "#/definitions/FacePoint"
          },
          "type": "array"
        },
        "LeftEyebrow": {
          "description": "Point locations of the left eyebrow (the eyebrow cloesest to the left side of the picture)",
          "items": {
            "$ref": "#/definitions/FacePoint"
          },
          "type": "array"
        },
        "LeftX": {
          "description": "X coordinate of the left side of the face",
          "format": "int32",
          "type": "integer"
        },
        "LipsInnerOutline": {
          "description": "Point locations of the inner outline of the lips",
          "items": {
            "$ref": "#/definitions/FacePoint"
          },
          "type": "array"
        },
        "LipsOuterOutline": {
          "description": "Point locations of the outer outline of the lips",
          "items": {
            "$ref": "#/definitions/FacePoint"
          },
          "type": "array"
        },
        "NoseBottom": {
          "description": "Point locations of the bottom (nostrils) of the nose",
          "items": {
            "$ref": "#/definitions/FacePoint"
          },
          "type": "array"
        },
        "NoseBridge": {
          "description": "Point locations of the nose bridge (the vertical portion of the nose)",
          "items": {
            "$ref": "#/definitions/FacePoint"
          },
          "type": "array"
        },
        "RightEye": {
          "description": "Point locations of the right eye (the eye closest to the right side of the picture)",
          "items": {
            "$ref": "#/definitions/FacePoint"
          },
          "type": "array"
        },
        "RightEyebrow": {
          "description": "Point locations of the right eyebrow (the eyebrow cloesest to the right side of the picture)",
          "items": {
            "$ref": "#/definitions/FacePoint"
          },
          "type": "array"
        },
        "RightX": {
          "description": "X coordinate of the right side of the face",
          "format": "int32",
          "type": "integer"
        },
        "TopY": {
          "description": "Y coordinate of the top side of the face",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "FindSymbolResult": {
      "description": "Result of a find symbol operation on an input image",
      "properties": {
        "Height": {
          "description": "Height of the found location in pixels",
          "format": "int32",
          "type": "integer"
        },
        "MatchScore": {
          "description": "Score between 0.0 and 1.0 that measures how closely the symbol matched; scores above 0.2 are good",
          "format": "double",
          "type": "number"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "Width": {
          "description": "Width of the found location in pixels",
          "format": "int32",
          "type": "integer"
        },
        "XLeft": {
          "description": "X location of the left edge of the found location in pixels",
          "format": "int32",
          "type": "integer"
        },
        "YTop": {
          "description": "Y location of the top edge of the found location in pixels",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "FineTextDetectionResult": {
      "description": "Result of an operation to detect text in a photo",
      "properties": {
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        },
        "TextItems": {
          "description": "Text items found in the input image",
          "items": {
            "$ref": "#/definitions/FineTextItem"
          },
          "type": "array"
        },
        "TextItemsCount": {
          "description": "Count of text items found in the input image",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "FineTextItem": {
      "description": "Individual instance of text occuring in an image; one piece of text",
      "properties": {
        "Angle": {
          "description": "Rotation Angle in radians of the text",
          "format": "double",
          "type": "number"
        },
        "BottomLeftX": {
          "description": "X coordinate of the bottom/left text location; 0 represents the left edge of the input image",
          "format": "int32",
          "type": "integer"
        },
        "BottomLeftY": {
          "description": "Y coordinate of the bottom/left text location; 0 represents the top edge of the input image",
          "format": "int32",
          "type": "integer"
        },
        "BottomRightX": {
          "description": "X coordinate of the bottom/right text location; 0 represents the left edge of the input image",
          "format": "int32",
          "type": "integer"
        },
        "BottomRightY": {
          "description": "Y coordinate of the bottom/right text location; 0 represents the top edge of the input image",
          "format": "int32",
          "type": "integer"
        },
        "Height": {
          "description": "Height in pixels of the text",
          "format": "int32",
          "type": "integer"
        },
        "TopLeftX": {
          "description": "X coordinate of the top/left text location; 0 represents the left edge of the input image",
          "format": "int32",
          "type": "integer"
        },
        "TopLeftY": {
          "description": "Y coordinate of the top/left text location; 0 represents the top edge of the input image",
          "format": "int32",
          "type": "integer"
        },
        "TopRightX": {
          "description": "X coordinate of the top/right text location; 0 represents the left edge of the input image",
          "format": "int32",
          "type": "integer"
        },
        "TopRightY": {
          "description": "Y coordinate of the top/right text location; 0 represents the top edge of the input image",
          "format": "int32",
          "type": "integer"
        },
        "Width": {
          "description": "Width in pixels of the text",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "GenderDetectionResult": {
      "description": "Result from classifying the Gender of people in an image",
      "properties": {
        "PeopleIdentified": {
          "description": "Number of people identified in the image with a gender",
          "format": "int32",
          "type": "integer"
        },
        "PersonWithGender": {
          "description": "People in the image annotated with gender information",
          "items": {
            "$ref": "#/definitions/PersonWithGender"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ImageDescriptionResponse": {
      "description": "Result of recognizing an image",
      "properties": {
        "BestOutcome": {
          "$ref": "#/definitions/RecognitionOutcome",
          "description": "The best Machine Learning outcome"
        },
        "Highconfidence": {
          "description": "Is the resulting best outcome recognition a high confidence outcome?",
          "type": "boolean"
        },
        "RunnerUpOutcome": {
          "$ref": "#/definitions/RecognitionOutcome",
          "description": "Best backup (\"runner up\") Machine Learning outcome"
        },
        "Successful": {
          "description": "Was the image processed successfully?",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ImageMetadata": {
      "description": "Metadata from an image",
      "properties": {
        "BitDepth": {
          "description": "Bits per pixel",
          "format": "int32",
          "type": "integer"
        },
        "ColorSpace": {
          "description": "Color space of the image",
          "type": "string"
        },
        "ExifProfileName": {
          "description": "Name of the EXIF profile used",
          "type": "string"
        },
        "ExifValues": {
          "description": "EXIF tags and values embedded in the image",
          "items": {
            "$ref": "#/definitions/ImageMetadataExifValue"
          },
          "type": "array"
        },
        "FileFormat": {
          "description": "File format of the image",
          "type": "string"
        },
        "Height": {
          "description": "Height of the image in pixels",
          "format": "int32",
          "type": "integer"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        },
        "Width": {
          "description": "Width of the image in pixels",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "ImageMetadataExifValue": {
      "description": "EXIF tag and value",
      "properties": {
        "DataType": {
          "description": "Date type of the EXIF value",
          "type": "string"
        },
        "DataValue": {
          "description": "Value, formatted as a string of the EXIF value",
          "type": "string"
        },
        "Tag": {
          "description": "Tag name for the EXIF value",
          "type": "string"
        }
      },
      "type": "object"
    },
    "NsfwResult": {
      "description": "Result of an NSFW classification",
      "properties": {
        "ClassificationOutcome": {
          "description": "Classification result into four categories: SafeContent_HighProbability, UnsafeContent_HighProbability, RacyContent, SafeContent_ModerateProbability",
          "type": "string"
        },
        "Score": {
          "description": "Score between 0.0 and 1.0.  Scores of 0.0-0.2 represent high probability safe content, while scores 0.8-1.0 represent high probability unsafe content.  Content between 0.2 and 0.8 is of increasing raciness.",
          "format": "double",
          "type": "number"
        },
        "Successful": {
          "description": "True if the classification was successfully run, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ObjectDetectionResult": {
      "description": "Result of detecting objects in an image",
      "properties": {
        "ObjectCount": {
          "description": "Number of objects detected in the scene",
          "format": "int32",
          "type": "integer"
        },
        "Objects": {
          "description": "Array of objects detected in the scene",
          "items": {
            "$ref": "#/definitions/DetectedObject"
          },
          "type": "array"
        },
        "Successful": {
          "description": "Was the image processed successfully?",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "PersonWithAge": {
      "description": "A person identified in an image age classification operation",
      "properties": {
        "Age": {
          "format": "double",
          "type": "number"
        },
        "AgeClass": {
          "description": "The person's age range classification result in years; possible values are \"0-2\", \"4-6\", \"8-13\", \"15-20\", \"25-32\", \"38-43\", \"48-53\", \"60+\"",
          "type": "string"
        },
        "AgeClassificationConfidence": {
          "description": "Confidence level of age classification; possible values are between 0.0 and 1.0; higher is better, with values &gt; 0.50 being high confidence results",
          "format": "double",
          "type": "number"
        },
        "FaceLocation": {
          "$ref": "#/definitions/Face",
          "description": "Location and other information about the person's face corresponding to this age classification"
        }
      },
      "type": "object"
    },
    "PersonWithGender": {
      "description": "A person identified in an image gender classification operation",
      "properties": {
        "FaceLocation": {
          "$ref": "#/definitions/Face",
          "description": "Location and other information about the person's face corresponding to this age classification"
        },
        "GenderClass": {
          "description": "The person's identified gender; possible values are \"Male\", \"Female\" and \"Unknown\"",
          "type": "string"
        },
        "GenderClassificationConfidence": {
          "description": "Confidence level of gender classification; possible values are between 0.0 and 1.0; higher is better, with values &gt; 0.50 being high confidence results",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "PolygonPoint": {
      "description": "One point in a polygon",
      "properties": {
        "X": {
          "description": "X location in pixels of this point in the polygon",
          "format": "double",
          "type": "number"
        },
        "Y": {
          "description": "Y location in pixels of this point in the polygon",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "RecognitionOutcome": {
      "description": "Specific recognition outcome",
      "properties": {
        "ConfidenceScore": {
          "description": "Scores closer to 1 are better than scores closer to 0",
          "format": "double",
          "type": "number"
        },
        "Description": {
          "description": "English language description of the image",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TextDetectionResult": {
      "description": "Result of an operation to detect text in a photo",
      "properties": {
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        },
        "TextItems": {
          "description": "Text items found in the input image",
          "items": {
            "$ref": "#/definitions/TextItem"
          },
          "type": "array"
        },
        "TextItemsCount": {
          "description": "Count of text items found in the input image",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TextItem": {
      "description": "Individual instance of text occuring in an image; one piece of text",
      "properties": {
        "Height": {
          "description": "Height in pixels of the text item",
          "format": "int32",
          "type": "integer"
        },
        "LeftX": {
          "description": "Left X coordinate of the text location; 0 represents the left edge of the input image",
          "format": "int32",
          "type": "integer"
        },
        "TopY": {
          "description": "Top Y coordinate of the text location; 0 represents the top edge of the input image",
          "format": "int32",
          "type": "integer"
        },
        "Width": {
          "description": "Width in pixels of the text item",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "VehicleLicensePlateDetectionResult": {
      "description": "Result of detecting vehicle license plates in an image",
      "properties": {
        "DetectedLicensePlateCount": {
          "description": "The number of license plates detected in the image",
          "format": "int32",
          "type": "integer"
        },
        "DetectedLicensePlates": {
          "description": "License plates found in the image",
          "items": {
            "$ref": "#/definitions/DetectedLicensePlate"
          },
          "type": "array"
        },
        "Successful": {
          "description": "Was the image processed successfully?",
          "type": "boolean"
        }
      },
      "type": "object"
    }
  },
  "host": "api.cloudmersive.com",
  "info": {
    "description": "Image Recognition and Processing APIs let you use Machine Learning to recognize and process images, and also perform useful image modification operations.",
    "title": "Cloudmersive Image Processing",
    "version": "v1",
    "x-ms-api-annotation": {
      "status": "Preview"
    }
  },
  "paths": {
    "/image/artistic/painting/{style}": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Uses machine learning to automatically transform an image into an artistic painting.  Due to depth of AI processing, depending on image size this operation can take up to 20 seconds.",
        "operationId": "Artistic_Painting",
        "parameters": [
          {
            "description": "The style of the painting to apply.  To start, try \"udnie\" a painting ...",
            "in": "path",
            "name": "style",
            "required": true,
            "type": "string",
            "x-ms-summary": "The style of the painting to apply.  To start, try \"udnie\" a painting ..."
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Transform an image into an artistic painting automatically",
        "tags": [
          "Artistic"
        ]
      }
    },
    "/image/convert/to/bmp": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Converts the input image into PSD format.  Supported input file formats include AAI, ART, ARW, AVS, BPG, BMP, BMP2, BMP3, BRF, CALS, CGM, CIN, CMYK, CMYKA, CR2, CRW, CUR, CUT, DCM, DCR, DCX, DDS, DIB, DJVU, DNG, DOT, DPX, EMF, EPDF, EPI, EPS, EPS2, EPS3, EPSF, EPSI, EPT, EXR, FAX, FIG, FITS, FPX, GIF, GPLT, GRAY, HDR, HEIC, HPGL, HRZ, ICO, ISOBRL, ISBRL6, JBIG, JNG, JP2, JPT, J2C, J2K, JPEG/JPG, JXR, MAT, MONO, MNG, M2V, MRW, MTV, NEF, ORF, OTB, P7, PALM, PAM, PBM, PCD, PCDS, PCL, PCX, PDF, PEF, PES, PFA, PFB, PFM, PGM, PICON, PICT, PIX, PNG, PNG8, PNG00, PNG24, PNG32, PNG48, PNG64, PNM, PPM, PSB, PSD, PTIF, PWB, RAD, RAF, RGB, RGBA, RGF, RLA, RLE, SCT, SFW, SGI, SID, SUN, SVG, TGA, TIFF, TIM, UIL, VIFF, VICAR, VBMP, WDP, WEBP, WPG, X, XBM, XCF, XPM, XWD, X3F, YCbCr, YCbCrA, YUV.",
        "operationId": "Convert_ToBmp",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Convert input image to Bitmap BMP format",
        "tags": [
          "Convert"
        ]
      }
    },
    "/image/convert/to/gif": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Converts the input image into GIF format.  Supported input file formats include AAI, ART, ARW, AVS, BPG, BMP, BMP2, BMP3, BRF, CALS, CGM, CIN, CMYK, CMYKA, CR2, CRW, CUR, CUT, DCM, DCR, DCX, DDS, DIB, DJVU, DNG, DOT, DPX, EMF, EPDF, EPI, EPS, EPS2, EPS3, EPSF, EPSI, EPT, EXR, FAX, FIG, FITS, FPX, GIF, GPLT, GRAY, HDR, HEIC, HPGL, HRZ, ICO, ISOBRL, ISBRL6, JBIG, JNG, JP2, JPT, J2C, J2K, JPEG/JPG, JXR, MAT, MONO, MNG, M2V, MRW, MTV, NEF, ORF, OTB, P7, PALM, PAM, PBM, PCD, PCDS, PCL, PCX, PDF, PEF, PES, PFA, PFB, PFM, PGM, PICON, PICT, PIX, PNG, PNG8, PNG00, PNG24, PNG32, PNG48, PNG64, PNM, PPM, PSB, PSD, PTIF, PWB, RAD, RAF, RGB, RGBA, RGF, RLA, RLE, SCT, SFW, SGI, SID, SUN, SVG, TGA, TIFF, TIM, UIL, VIFF, VICAR, VBMP, WDP, WEBP, WPG, X, XBM, XCF, XPM, XWD, X3F, YCbCr, YCbCrA, YUV.",
        "operationId": "Convert_ToGif",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Convert input image to GIF format",
        "tags": [
          "Convert"
        ]
      }
    },
    "/image/convert/to/jpg/{quality}": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Converts the input image into JPEG/JPG format.  Customize encoding parameters.  Supported input file formats include AAI, ART, ARW, AVS, BPG, BMP, BMP2, BMP3, BRF, CALS, CGM, CIN, CMYK, CMYKA, CR2, CRW, CUR, CUT, DCM, DCR, DCX, DDS, DIB, DJVU, DNG, DOT, DPX, EMF, EPDF, EPI, EPS, EPS2, EPS3, EPSF, EPSI, EPT, EXR, FAX, FIG, FITS, FPX, GIF, GPLT, GRAY, HDR, HEIC, HPGL, HRZ, ICO, ISOBRL, ISBRL6, JBIG, JNG, JP2, JPT, J2C, J2K, JPEG/JPG, JXR, MAT, MONO, MNG, M2V, MRW, MTV, NEF, ORF, OTB, P7, PALM, PAM, PBM, PCD, PCDS, PCL, PCX, PDF, PEF, PES, PFA, PFB, PFM, PGM, PICON, PICT, PIX, PNG, PNG8, PNG00, PNG24, PNG32, PNG48, PNG64, PNM, PPM, PSB, PSD, PTIF, PWB, RAD, RAF, RGB, RGBA, RGF, RLA, RLE, SCT, SFW, SGI, SID, SUN, SVG, TGA, TIFF, TIM, UIL, VIFF, VICAR, VBMP, WDP, WEBP, WPG, X, XBM, XCF, XPM, XWD, X3F, YCbCr, YCbCrA, YUV.",
        "operationId": "Convert_ToJpg",
        "parameters": [
          {
            "description": "Set the JPEG quality level; lowest quality is 1 (highest compression),...",
            "format": "int32",
            "in": "path",
            "name": "quality",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Set the JPEG quality level; lowest quality is 1 (highest compression),..."
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Convert input image to JPG, JPEG format",
        "tags": [
          "Convert"
        ]
      }
    },
    "/image/convert/to/png": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Converts the input image into PNG format.  Transparency is preserved when present.  Supported input file formats include AAI, ART, ARW, AVS, BPG, BMP, BMP2, BMP3, BRF, CALS, CGM, CIN, CMYK, CMYKA, CR2, CRW, CUR, CUT, DCM, DCR, DCX, DDS, DIB, DJVU, DNG, DOT, DPX, EMF, EPDF, EPI, EPS, EPS2, EPS3, EPSF, EPSI, EPT, EXR, FAX, FIG, FITS, FPX, GIF, GPLT, GRAY, HDR, HEIC, HPGL, HRZ, ICO, ISOBRL, ISBRL6, JBIG, JNG, JP2, JPT, J2C, J2K, JPEG/JPG, JXR, MAT, MONO, MNG, M2V, MRW, MTV, NEF, ORF, OTB, P7, PALM, PAM, PBM, PCD, PCDS, PCL, PCX, PDF, PEF, PES, PFA, PFB, PFM, PGM, PICON, PICT, PIX, PNG, PNG8, PNG00, PNG24, PNG32, PNG48, PNG64, PNM, PPM, PSB, PSD, PTIF, PWB, RAD, RAF, RGB, RGBA, RGF, RLA, RLE, SCT, SFW, SGI, SID, SUN, SVG, TGA, TIFF, TIM, UIL, VIFF, VICAR, VBMP, WDP, WEBP, WPG, X, XBM, XCF, XPM, XWD, X3F, YCbCr, YCbCrA, YUV.",
        "operationId": "Convert_ToPng",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Convert input image to PNG format",
        "tags": [
          "Convert"
        ]
      }
    },
    "/image/convert/to/psd": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Converts the input image into PSD format.  Supported input file formats include AAI, ART, ARW, AVS, BPG, BMP, BMP2, BMP3, BRF, CALS, CGM, CIN, CMYK, CMYKA, CR2, CRW, CUR, CUT, DCM, DCR, DCX, DDS, DIB, DJVU, DNG, DOT, DPX, EMF, EPDF, EPI, EPS, EPS2, EPS3, EPSF, EPSI, EPT, EXR, FAX, FIG, FITS, FPX, GIF, GPLT, GRAY, HDR, HEIC, HPGL, HRZ, ICO, ISOBRL, ISBRL6, JBIG, JNG, JP2, JPT, J2C, J2K, JPEG/JPG, JXR, MAT, MONO, MNG, M2V, MRW, MTV, NEF, ORF, OTB, P7, PALM, PAM, PBM, PCD, PCDS, PCL, PCX, PDF, PEF, PES, PFA, PFB, PFM, PGM, PICON, PICT, PIX, PNG, PNG8, PNG00, PNG24, PNG32, PNG48, PNG64, PNM, PPM, PSB, PSD, PTIF, PWB, RAD, RAF, RGB, RGBA, RGF, RLA, RLE, SCT, SFW, SGI, SID, SUN, SVG, TGA, TIFF, TIM, UIL, VIFF, VICAR, VBMP, WDP, WEBP, WPG, X, XBM, XCF, XPM, XWD, X3F, YCbCr, YCbCrA, YUV.",
        "operationId": "Convert_ToPhotoshop",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Convert input image to Photoshop PSD format",
        "tags": [
          "Convert"
        ]
      }
    },
    "/image/convert/to/tiff": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Converts the input image into TIFF format.  Supported input file formats include AAI, ART, ARW, AVS, BPG, BMP, BMP2, BMP3, BRF, CALS, CGM, CIN, CMYK, CMYKA, CR2, CRW, CUR, CUT, DCM, DCR, DCX, DDS, DIB, DJVU, DNG, DOT, DPX, EMF, EPDF, EPI, EPS, EPS2, EPS3, EPSF, EPSI, EPT, EXR, FAX, FIG, FITS, FPX, GIF, GPLT, GRAY, HDR, HEIC, HPGL, HRZ, ICO, ISOBRL, ISBRL6, JBIG, JNG, JP2, JPT, J2C, J2K, JPEG/JPG, JXR, MAT, MONO, MNG, M2V, MRW, MTV, NEF, ORF, OTB, P7, PALM, PAM, PBM, PCD, PCDS, PCL, PCX, PDF, PEF, PES, PFA, PFB, PFM, PGM, PICON, PICT, PIX, PNG, PNG8, PNG00, PNG24, PNG32, PNG48, PNG64, PNM, PPM, PSB, PSD, PTIF, PWB, RAD, RAF, RGB, RGBA, RGF, RLA, RLE, SCT, SFW, SGI, SID, SUN, SVG, TGA, TIFF, TIM, UIL, VIFF, VICAR, VBMP, WDP, WEBP, WPG, X, XBM, XCF, XPM, XWD, X3F, YCbCr, YCbCrA, YUV.",
        "operationId": "Convert_ToTiff",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Convert input image to TIFF format",
        "tags": [
          "Convert"
        ]
      }
    },
    "/image/convert/to/webp": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Converts the input image into WebP format.  Supported input file formats include AAI, ART, ARW, AVS, BPG, BMP, BMP2, BMP3, BRF, CALS, CGM, CIN, CMYK, CMYKA, CR2, CRW, CUR, CUT, DCM, DCR, DCX, DDS, DIB, DJVU, DNG, DOT, DPX, EMF, EPDF, EPI, EPS, EPS2, EPS3, EPSF, EPSI, EPT, EXR, FAX, FIG, FITS, FPX, GIF, GPLT, GRAY, HDR, HEIC, HPGL, HRZ, ICO, ISOBRL, ISBRL6, JBIG, JNG, JP2, JPT, J2C, J2K, JPEG/JPG, JXR, MAT, MONO, MNG, M2V, MRW, MTV, NEF, ORF, OTB, P7, PALM, PAM, PBM, PCD, PCDS, PCL, PCX, PDF, PEF, PES, PFA, PFB, PFM, PGM, PICON, PICT, PIX, PNG, PNG8, PNG00, PNG24, PNG32, PNG48, PNG64, PNM, PPM, PSB, PSD, PTIF, PWB, RAD, RAF, RGB, RGBA, RGF, RLA, RLE, SCT, SFW, SGI, SID, SUN, SVG, TGA, TIFF, TIM, UIL, VIFF, VICAR, VBMP, WDP, WEBP, WPG, X, XBM, XCF, XPM, XWD, X3F, YCbCr, YCbCrA, YUV.",
        "operationId": "Convert_ToWebP",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Convert input image to WebP format",
        "tags": [
          "Convert"
        ]
      }
    },
    "/image/edit/auto-orient/remove-exif": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Automatically orients the input image based on EXIF information and then removes the EXIF information.  EXIF is an additional set of information stored in some images taken with cell phone cameras based on the orientation of the camera.  By normalizing rotation and removing EXIF data these images become much easier to process.",
        "operationId": "Edit_AutoOrient",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Normalizes image rotation and removes EXIF rotation data",
        "tags": [
          "Edit"
        ]
      }
    },
    "/image/edit/composite/{location}": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Composites two input images together; a layered image onto a base image.  The first image you input is the base image.  The second image (the layered image) will be composited on top of this base image.  Supports PNG transparency.  To control padding you can include transparent pixels at the border(s) of your layered images as appropriate.",
        "operationId": "Edit_CompositeBasic",
        "parameters": [
          {
            "description": "Location to composite the layered images; possible values are: \"center...",
            "in": "path",
            "name": "location",
            "required": true,
            "type": "string",
            "x-ms-summary": "Location to composite the layered images; possible values are: \"center..."
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "baseImage",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          },
          {
            "description": "Image to layer on top of the base image.",
            "in": "formData",
            "name": "layeredImage",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image to layer on top of the base image."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Composite two images together",
        "tags": [
          "Edit"
        ]
      }
    },
    "/image/edit/contrast/{gamma}/adaptive": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Uses Gamma to adjust the contrast adaptively the way the human eye sees the world.  Results significantly improve the viewability and visual appeal of the image.",
        "operationId": "Edit_ContrastAdaptive",
        "parameters": [
          {
            "description": "Gamma value to adjust the contrast in the image.  Recommended value is...",
            "format": "double",
            "in": "path",
            "name": "gamma",
            "required": true,
            "type": "number",
            "x-ms-summary": "Gamma value to adjust the contrast in the image.  Recommended value is..."
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Adaptively adjust the contrast of the image to be more appealing and easy to see",
        "tags": [
          "Edit"
        ]
      }
    },
    "/image/edit/crop/rectangle/{left}/{top}/{width}/{height}": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Crop an image to a target rectangular area",
        "operationId": "Edit_CropRectangle",
        "parameters": [
          {
            "description": "The left edge of the rectangular crop area in pixels (X).",
            "format": "int32",
            "in": "path",
            "name": "left",
            "required": true,
            "type": "integer",
            "x-ms-summary": "The left edge of the rectangular crop area in pixels (X)."
          },
          {
            "description": "The top edge of the rectangular crop area in pixels (Y).",
            "format": "int32",
            "in": "path",
            "name": "top",
            "required": true,
            "type": "integer",
            "x-ms-summary": "The top edge of the rectangular crop area in pixels (Y)."
          },
          {
            "description": "The width of the rectangular crop area in pixels.",
            "format": "int32",
            "in": "path",
            "name": "width",
            "required": true,
            "type": "integer",
            "x-ms-summary": "The width of the rectangular crop area in pixels."
          },
          {
            "description": "The height of the rectangular crop area in pixels.",
            "format": "int32",
            "in": "path",
            "name": "height",
            "required": true,
            "type": "integer",
            "x-ms-summary": "The height of the rectangular crop area in pixels."
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Crop an image to a rectangular area",
        "tags": [
          "Edit"
        ]
      }
    },
    "/image/edit/draw/polygon": {
      "post": {
        "consumes": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml",
          "application/x-www-form-urlencoded"
        ],
        "description": "Draw one or more polygons, with customized visuals, onto an image",
        "operationId": "Edit_DrawPolygon",
        "parameters": [
          {
            "description": "Polygon drawing request parameters",
            "in": "body",
            "name": "request",
            "required": true,
            "schema": {
              "$ref": "#/definitions/DrawPolygonRequest"
            },
            "x-ms-summary": "Polygon drawing request parameters"
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Draw a polygon onto an image",
        "tags": [
          "Edit"
        ]
      }
    },
    "/image/edit/draw/rectangle": {
      "post": {
        "consumes": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml",
          "application/x-www-form-urlencoded"
        ],
        "description": "Draw one or more rectangles, with customized visuals, onto an image",
        "operationId": "Edit_DrawRectangle",
        "parameters": [
          {
            "description": "Draw rectangle parameters",
            "in": "body",
            "name": "request",
            "required": true,
            "schema": {
              "$ref": "#/definitions/DrawRectangleRequest"
            },
            "x-ms-summary": "Draw rectangle parameters"
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Draw a rectangle onto an image",
        "tags": [
          "Edit"
        ]
      }
    },
    "/image/edit/draw/text": {
      "post": {
        "consumes": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml",
          "application/x-www-form-urlencoded"
        ],
        "description": "Draw one or more pieces of text, with customized visuals, onto an image",
        "operationId": "Edit_DrawText",
        "parameters": [
          {
            "description": "Draw text parameters",
            "in": "body",
            "name": "request",
            "required": true,
            "schema": {
              "$ref": "#/definitions/DrawTextRequest"
            },
            "x-ms-summary": "Draw text parameters"
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Draw text onto an image",
        "tags": [
          "Edit"
        ]
      }
    },
    "/image/edit/drop-shadow/{X}/{Y}/{sigma}/{opacity}": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Add a customizeable drop shadow to the image",
        "operationId": "Edit_DropShadow",
        "parameters": [
          {
            "description": "Horizontal (X) offset of the drop shadow",
            "format": "int32",
            "in": "path",
            "name": "X",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Horizontal (X) offset of the drop shadow"
          },
          {
            "description": "Vertical (Y) offset of the drop shadow",
            "format": "int32",
            "in": "path",
            "name": "Y",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Vertical (Y) offset of the drop shadow"
          },
          {
            "description": "Sigma (blur distance) of the drop shadow",
            "format": "int32",
            "in": "path",
            "name": "sigma",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Sigma (blur distance) of the drop shadow"
          },
          {
            "description": "Opacity of the drop shadow; 0 is 0% and 100 is 100%",
            "format": "int32",
            "in": "path",
            "name": "opacity",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Opacity of the drop shadow; 0 is 0% and 100 is 100%"
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Add a customizeable drop shadow to an image",
        "tags": [
          "Edit"
        ]
      }
    },
    "/image/edit/remove-transparency": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Removes any active transparency in the image.  Effectively renders the image at the same resolution, in the same file format, over a white background, thus removing transparency.",
        "operationId": "Edit_RemoveTransparency",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Remove transparency from the image",
        "tags": [
          "Edit"
        ]
      }
    },
    "/image/edit/rotate/{degrees}/angle": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Rotates an image by an arbitrary number of degrees",
        "operationId": "Edit_Rotate",
        "parameters": [
          {
            "description": "Degrees to rotate the image; values range from 0.0 to 360.0.",
            "format": "double",
            "in": "path",
            "name": "degrees",
            "required": true,
            "type": "number",
            "x-ms-summary": "Degrees to rotate the image; values range from 0.0 to 360.0."
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Rotate an image any number of degrees",
        "tags": [
          "Edit"
        ]
      }
    },
    "/image/face/compare-and-match": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Find the faces in an input image, and compare against a reference image to determine if there is a match against the face in the reference image.  The reference image (second parameter) should contain exactly one face.",
        "operationId": "Face_Compare",
        "parameters": [
          {
            "description": "Image file to perform the operation on; this image can contain one or ...",
            "in": "formData",
            "name": "inputImage",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on; this image can contain one or ..."
          },
          {
            "description": "Image of a single face to compare and match against.",
            "in": "formData",
            "name": "matchFace",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image of a single face to compare and match against."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FaceCompareResponse"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Compare and match faces",
        "tags": [
          "Face"
        ]
      }
    },
    "/image/face/crop/first": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Crop an image to the face (rectangular crop).  If there is more than one face present, choose the first one.",
        "operationId": "Face_CropFirst",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Crop image to face with square crop",
        "tags": [
          "Face"
        ]
      }
    },
    "/image/face/crop/first/round": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Crop an image to the face (circular/round crop).  If there is more than one face present, choose the first one.",
        "operationId": "Face_CropFirstRound",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Crop image to face with round crop",
        "tags": [
          "Face"
        ]
      }
    },
    "/image/face/detect-age": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Identify the age, position, and size of human faces in an image, along with a recognition confidence level.  People in the image do NOT need to be facing the camera; they can be facing away, edge-on, etc.",
        "operationId": "Face_DetectAge",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/AgeDetectionResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Detect the age of people in an image",
        "tags": [
          "Face"
        ]
      }
    },
    "/image/face/detect-gender": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Identify the gender, position, and size of human faces in an image, along with a recognition confidence level.  People in the image should be facing the camera.",
        "operationId": "Face_DetectGender",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GenderDetectionResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Detect the gender of people in an image",
        "tags": [
          "Face"
        ]
      }
    },
    "/image/face/locate": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Locate the positions of all faces in an image",
        "operationId": "Face_Locate",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FaceLocateResponse"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Detect and find faces in an image",
        "tags": [
          "Face"
        ]
      }
    },
    "/image/face/locate-with-landmarks": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Locate the positions of all faces in an image, along with the eyes, eye brows, nose and mouth components of each",
        "operationId": "Face_LocateWithLandmarks",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FaceLocateWithLandmarksResponse"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Detect and find faces and landmarks eyes and nose and mouth in image",
        "tags": [
          "Face"
        ]
      }
    },
    "/image/filter/black-and-white": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Remove color from the image by converting to a grayscale, black-and-white image",
        "operationId": "Filter_BlackAndWhite",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Convert image to black-and-white grayscale",
        "tags": [
          "Filter"
        ]
      }
    },
    "/image/filter/blur/guassian/{radius}/{sigma}": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Perform a gaussian blur on the input image",
        "operationId": "Filter_GaussianBlur",
        "parameters": [
          {
            "description": "Radius in pixels of the blur operation; a larger radius will produce a...",
            "format": "int32",
            "in": "path",
            "name": "radius",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Radius in pixels of the blur operation; a larger radius will produce a..."
          },
          {
            "description": "Sigma, or variance, of the gaussian blur operation",
            "format": "int32",
            "in": "path",
            "name": "sigma",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Sigma, or variance, of the gaussian blur operation"
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Perform a guassian blur on the input image",
        "tags": [
          "Filter"
        ]
      }
    },
    "/image/filter/blur/motion/{radius}/{sigma}/{angle}": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Perform a motion blur on the input image at a specific angle",
        "operationId": "Filter_MotionBlur",
        "parameters": [
          {
            "description": "Radius in pixels of the blur operation; a larger radius will produce a...",
            "format": "int32",
            "in": "path",
            "name": "radius",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Radius in pixels of the blur operation; a larger radius will produce a..."
          },
          {
            "description": "Sigma, or variance, of the motion blur operation",
            "format": "int32",
            "in": "path",
            "name": "sigma",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Sigma, or variance, of the motion blur operation"
          },
          {
            "description": "Angle of the motion blur in degrees",
            "format": "int32",
            "in": "path",
            "name": "angle",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Angle of the motion blur in degrees"
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Perform a motion blur on the input image",
        "tags": [
          "Filter"
        ]
      }
    },
    "/image/filter/despeckle": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Remove point noise / despeckle the input image",
        "operationId": "Filter_Despeckle",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Despeckle to remove point noise from the image",
        "tags": [
          "Filter"
        ]
      }
    },
    "/image/filter/edge-detect/{radius}": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Perform an edge detection operation on the input image",
        "operationId": "Filter_EdgeDetect",
        "parameters": [
          {
            "description": "Radius in pixels of the edge detection operation; a larger radius will...",
            "format": "int32",
            "in": "path",
            "name": "radius",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Radius in pixels of the edge detection operation; a larger radius will..."
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Detect and highlight edges in an image",
        "tags": [
          "Filter"
        ]
      }
    },
    "/image/filter/emboss/{radius}/{sigma}": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Perform an emboss operation on the input image",
        "operationId": "Filter_Emboss",
        "parameters": [
          {
            "description": "Radius in pixels of the emboss operation; a larger radius will produce...",
            "format": "int32",
            "in": "path",
            "name": "radius",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Radius in pixels of the emboss operation; a larger radius will produce..."
          },
          {
            "description": "Sigma, or variance, of the emboss operation",
            "format": "int32",
            "in": "path",
            "name": "sigma",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Sigma, or variance, of the emboss operation"
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Emboss an image",
        "tags": [
          "Filter"
        ]
      }
    },
    "/image/filter/posterize": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Reduce the unique number of colors in the image to the specified level",
        "operationId": "Filter_Posterize",
        "parameters": [
          {
            "description": "Number of unique colors to retain in the output image",
            "format": "int32",
            "in": "query",
            "name": "levels",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Number of unique colors to retain in the output image"
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Posterize the image by reducing distinct colors",
        "tags": [
          "Filter"
        ]
      }
    },
    "/image/filter/swirl": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Swirl distort the image by the specified number of degrees",
        "operationId": "Filter_Swirl",
        "parameters": [
          {
            "description": "Degrees of swirl",
            "format": "int32",
            "in": "query",
            "name": "degrees",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Degrees of swirl"
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Swirl distort the image",
        "tags": [
          "Filter"
        ]
      }
    },
    "/image/get-info/dominant-color": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Uses advanced image processing to extract the top 5 dominant colors in the image, returned in the order of dominance with the most-dominant color first.  These are the primary perceptual colors used in the image as perceived by a viewer.",
        "operationId": "Info_GetDominantColor",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/DominantColorResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Returns the dominant colors of the image",
        "tags": [
          "Info"
        ]
      }
    },
    "/image/get-info/metadata": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Returns the metadata information on the image, including file type, EXIF (if available), and resolution.",
        "operationId": "Info_GetMetadata",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ImageMetadata"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Returns the image metadata including EXIF and resolution",
        "tags": [
          "Info"
        ]
      }
    },
    "/image/nsfw/classify": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Classify an image into Not Safe For Work (NSFW)/Porn/Racy content and Safe Content.",
        "operationId": "Nsfw_Classify",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/NsfwResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Not safe for work NSFW racy content classification",
        "tags": [
          "Nsfw"
        ]
      }
    },
    "/image/recognize/describe": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Generate an English language text description of the image as a sentence.",
        "operationId": "Recognize_Describe",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ImageDescriptionResponse"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Describe an image in natural language",
        "tags": [
          "Recognize"
        ]
      }
    },
    "/image/recognize/detect-document/unskew": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Detect and unskew a photo of a document (e.g. taken on a cell phone) into a perfectly square image.  Great for document scanning applications; once unskewed, this image is perfect for converting to PDF using the Convert API or optical character recognition using the OCR API.",
        "operationId": "Recognize_DetectAndUnskewDocument",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          },
          {
            "description": "Optional, post-processing effects to apply to the email, default is No...",
            "in": "header",
            "name": "PostProcessingEffect",
            "required": false,
            "type": "string",
            "x-ms-summary": "Optional, post-processing effects to apply to the email, default is No..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "byte",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Detect and unskew a photo of a document",
        "tags": [
          "Recognize"
        ]
      }
    },
    "/image/recognize/detect-objects": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Identify the position, size and description of objects in an image, along with a recognition confidence level.  Detects both human people and objects in an image.",
        "operationId": "Recognize_DetectObjects",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ObjectDetectionResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Detect objects including types and locations in an image",
        "tags": [
          "Recognize"
        ]
      }
    },
    "/image/recognize/detect-people": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Identify the position, and size of human people in an image, along with a recognition confidence level.  People in the image do NOT need to be facing the camera; they can be facing away, edge-on, etc.",
        "operationId": "Recognize_DetectPeople",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/ObjectDetectionResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Detect people including locations in an image",
        "tags": [
          "Recognize"
        ]
      }
    },
    "/image/recognize/detect-text/fine": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Identify the position, and size of small/fine text within a photograph of a document.  Identify the location of small text in a photo - such as words and other forms of high density text.  Can be used on a scan of a document or a photograph (e.g. smartphone camera) of a document, page or receipt.  For OCR purposes - please see our Deep Learning OCR APIs.",
        "operationId": "Recognize_DetectTextFine",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FineTextDetectionResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Detect fine text in a photo of a document",
        "tags": [
          "Recognize"
        ]
      }
    },
    "/image/recognize/detect-text/large": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Identify the position, and size of large text within a photograph.  Identify the location of large text in a photo - such as signs, titles, etc. and other forms of large, low-density text.  Not suitable for high-density text (e.g. scans of documents, receipts, etc.) for OCR purposes - for OCR, please see our Deep Learning OCR APIs.",
        "operationId": "Recognize_DetectTextLarge",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/TextDetectionResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Detect large text in a photo",
        "tags": [
          "Recognize"
        ]
      }
    },
    "/image/recognize/detect-vehicle-license-plates": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Identify the position, and size, and content of vehicle license plates in an image.  License plates should be within 15-20 degrees on-axis to the camera.",
        "operationId": "Recognize_DetectVehicleLicensePlates",
        "parameters": [
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/VehicleLicensePlateDetectionResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Detect vehicle license plates in an image",
        "tags": [
          "Recognize"
        ]
      }
    },
    "/image/recognize/find/symbol": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Determine if an image contains a symbol, and if so, the location of that symbol in the image.",
        "operationId": "Recognize_FindSymbol",
        "parameters": [
          {
            "description": "Image file to search through for the target image.",
            "in": "formData",
            "name": "inputImage",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to search through for the target image."
          },
          {
            "description": "Image to find in the input image.",
            "in": "formData",
            "name": "targetImage",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image to find in the input image."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/FindSymbolResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Find the location of a symbol in an image",
        "tags": [
          "Recognize"
        ]
      }
    },
    "/image/resize/preserveAspectRatio/{maxWidth}/{maxHeight}": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Resize an image to a maximum width and maximum height, while preserving the image's original aspect ratio",
        "operationId": "Resize_Post",
        "parameters": [
          {
            "description": "Maximum width of the output image - final image will be as large as po...",
            "format": "int32",
            "in": "path",
            "name": "maxWidth",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Maximum width of the output image - final image will be as large as po..."
          },
          {
            "description": "Maximum height of the output image - final image will be as large as p...",
            "format": "int32",
            "in": "path",
            "name": "maxHeight",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Maximum height of the output image - final image will be as large as p..."
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Resize an image while preserving aspect ratio",
        "tags": [
          "Resize"
        ]
      }
    },
    "/image/resize/target/{width}/{height}": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Resize an image to a specific width and specific height",
        "operationId": "Resize_ResizeSimple",
        "parameters": [
          {
            "description": "Width of the output image - final image will be exactly this width",
            "format": "int32",
            "in": "path",
            "name": "width",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Width of the output image - final image will be exactly this width"
          },
          {
            "description": "Height of the output image - final image will be exactly this height",
            "format": "int32",
            "in": "path",
            "name": "height",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Height of the output image - final image will be exactly this height"
          },
          {
            "description": "Image file to perform the operation on.  Common file formats such as P...",
            "in": "formData",
            "name": "imageFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Image file to perform the operation on.  Common file formats such as P..."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "format": "binary",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Resize an image",
        "tags": [
          "Resize"
        ]
      }
    }
  },
  "schemes": [
    "https"
  ],
  "securityDefinitions": {
    "Apikey": {
      "description": "API Key Authentication",
      "in": "header",
      "name": "Apikey",
      "type": "apiKey"
    }
  },
  "swagger": "2.0"
}