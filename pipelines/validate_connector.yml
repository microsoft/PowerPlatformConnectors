pool:
  vmImage: 'vs2017-win2016'

variables:
  resourceStackFolder: $(System.ArtifactsDirectory)/resourstack
  
steps:
- task: DownloadPackage@1
  inputs:
    packageType: 'nuget'
    feed: 'Official@Local'
    definition: 'Microsoft.WindowsAzure.ResourceStack'
    version: $(resourceStackVersion)
    downloadPath: $(resourceStackFolder)
- task: DownloadPackage@1
  inputs:
    packageType: 'nuget'
    feed: 'NugetMirror'
    definition: 'Newtonsoft.Json'
    version: $(newtonsoftVersion)
    downloadPath: $(resourceStackFolder)
- task: DownloadPackage@1
  inputs:
    packageType: 'nuget'
    feed: 'ManualMirror@Local'
    definition: 'BAPIConnectors.BreakingChangeDetector'
    version: $(bcdVersion) 
    downloadPath: $(bcdLocation)
- powershell: |
    # load libraries
    $newtonsoftPath = Join-Path $(resourceStackFolder) "/lib/netstandard2.0/Newtonsoft.Json.dll"
    $ResourceStackPath = Join-Path $(resourceStackFolder) "/lib/netstandard2.0/Microsoft.WindowsAzure.ResourceStack.dll"
    Add-Type -Path $newtonsoftPath
    Add-Type -Path $ResourceStackPath

    # initialize serializer and validation configuration
    $jsonSerializerSettings = New-Object Newtonsoft.Json.JsonSerializerSettings
    $jsonSerializerSettings.DateParseHandling = [Newtonsoft.Json.DateParseHandling]::None
    $jsonSerializerSettings.DateTimeZoneHandling = [Newtonsoft.Json.DateTimeZoneHandling]::Utc
    $jsonSerializer = [Newtonsoft.Json.JsonSerializer]::Create($jsonSerializerSettings)
    
    $configuration = New-Object Microsoft.WindowsAzure.ResourceStack.Common.Swagger.Validators.SwaggerValidationConfiguration
    $configuration.IsCertificationValidation = $(isCertificationValidation)
    
    $SourceRepo = [System.Uri]$Env:SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI
    $SourceRepo = $SourceRepo.AbsolutePath -replace '.git'

    $GitUrl = '$(githubapi)' + $SourceRepo + '/pulls/' + $Env:SYSTEM_PULLREQUEST_PULLREQUESTNUMBER + '/files'

    # Get the list of files for the given PR
    $Files = Invoke-RestMethod -Uri $GitUrl -Method Get

    ForEach ($File in $Files) {
      $filename = $File.filename
      if($filename.EndsWith('.swagger.json')) {
        Try
        {
            [System.IO.TextReader] $contentReader = New-Object System.IO.StringReader -ArgumentList @(Get-Content $file -Raw)
            [Newtonsoft.Json.Linq.JToken] $swaggerToken = $jsonSerializer.Deserialize($contentReader, [Newtonsoft.Json.Linq.JToken])
        }
        Catch [Newtonsoft.Json.JsonReaderException]
        {
            Write-Host "##vso[task.logissue type=error;sourcepath=$file;linenumber=$($_.Exception.LineNumber);columnnumber=$($_.Exception.LinePosition)]Swagger file '$file' is invalid. Details: $($_.Exception.Message)"
            $exitCode = 1
            continue
        }
        Catch
        {
            Write-Host "##vso[task.logissue type=error;sourcepath=$file;]Swagger file '$file' is empty or it has invalid json content. Details: $($_.Exception.Message)"
            $exitCode = 1
            continue
        }
        Finally
        {
            if($contentReader)
            {
                $contentReader.Dispose()
            }
        }

        $results = [Microsoft.WindowsAzure.ResourceStack.Common.Swagger.Validators.SwaggerValidator]::ValidateSwagger(`
            $swaggerToken,`
            [Microsoft.WindowsAzure.ResourceStack.Common.Swagger.Validators.SwaggerValidationVersion]::MAR2019,`
            $configuration)
            
        $warnings = $results.Where({$_.Level -EQ [Microsoft.WindowsAzure.ResourceStack.Common.Swagger.Validators.SwaggerValidationResultLevel]::Warning})
        $errors = $results.Where({$_.Level -IN [Microsoft.WindowsAzure.ResourceStack.Common.Swagger.Validators.SwaggerValidationResultLevel]::Error,`
                                                [Microsoft.WindowsAzure.ResourceStack.Common.Swagger.Validators.SwaggerValidationResultLevel]::Critical})
        if ($warnings)
        {
            $warnings.ForEach({Write-Host "##vso[task.logissue type=warning;sourcepath=$file;code=$($_.ErrorCode);]$($_.Message) ValuePath: '$($_.ValuePath)' Value: '$($_.Value)'"})
        }

        if ($errors)
        {
            $errors.ForEach({Write-Host "##vso[task.logissue type=error;sourcepath=$file;code=$($_.ErrorCode);]$($_.Message) ValuePath: '$($_.ValuePath)' Value: '$($_.Value)'"})
            Write-Host "##vso[task.logissue type=error;sourcepath=$file;]Swagger file '$file' contains error(s)."
            $exitCode = 1
        }
      }
    }
- powershell: |
    # load libraries
    $bcdPath = Join-Path "$(bcdLocation)" "/lib/net46/Microsoft.PowerPlatform.ConnectorPlatform.BreakingChangeDetector.dll"
    $newtonsoftPath = Join-Path "$(newtonsoftLocation)" "/lib/net45/Newtonsoft.Json.dll"
    $ResourceStackPath = Join-Path "$(resourceStackLocation)" "/lib/net461/Microsoft.WindowsAzure.ResourceStack.dll"

    # Assembly resolve handler for Newtonsoft and resourcestack from different folders/version
    $newtonsoft = [reflection.assembly]::LoadFrom($newtonsoftPath)
    $resourcestack = [reflection.assembly]::LoadFrom($ResourceStackPath) 

    $OnAssemblyResolve = [System.ResolveEventHandler] {
      param($sender, $e)

      if ($e.Name -like "Newtonsoft.Json*")
      {
        return $newtonsoft
      }

      if ($e.Name -like "Microsoft.WindowsAzure.ResourceStack*")
      {
        return $resourcestack
      }

      foreach($a in [System.AppDomain]::CurrentDomain.GetAssemblies())
      {
        if ($a.FullName -eq $e.Name)
      {
          return $a
        }
      }
      return $null
    }

    [System.AppDomain]::CurrentDomain.add_AssemblyResolve($OnAssemblyResolve)

    Add-Type -Path $bcdPath

    $oldFilePath = "$(aaptConnectorDir)\apiDefinition.swagger.json"
    $newFilePath = "$(GetSettings.SettingsDirectory)\apiDefinition.swagger.json"
    $results = [Microsoft.PowerPlatform.ConnectorPlatform.BreakingChangeDetector.SwaggerBreakingChangeDetector]::FindDocumentBreakingChanges($oldFilePath, $newFilePath)

    # We care about errors only
    $errors = $results | Where-Object -FilterScript {$_.Level -EQ "Error"}

    if ($errors) {
        # Write error and quit
        $errMessage = ($errors | Select-Object -Property LineNumber, ValuePath, Message | Format-Table | Out-String)
        Write-Host  "##vso[task.LogIssue type=error;]$errMessage"
        exit 1
    }
    
    $currentLocation = Get-Location
    $errorsTotal = 0
    $warningsTotal = 0


    foreach ($file in $files) { 
        if ($file -match '.+?apidefinition.swagger.json$') {
            $currentFilePath = Join-Path $currentLocation ($file.Replace('/', '\'))
            $previousCommitHash = git log --max-count=1 --skip=1 --first-parent --pretty=format:%H $currentFilePath

            if ($previousCommitHash) {
                $oldFilePath = Join-Path ([System.IO.Path]::GetTempPath()) ((Split-Path $file -leaf) + '.tmp')

                git show "$($previousCommitHash):$($file)" > $oldFilePath

                if (Test-Path $oldFilePath) {
                    $results = [Microsoft.PowerPlatform.ConnectorPlatform.BreakingChangeDetector.SwaggerBreakingChangeDetector]::FindDocumentBreakingChanges($oldFilePath, $currentFilePath)

                    $errors = $results | where { $_.Level -EQ [Microsoft.Azure.Connectors.BreakingChangeDetector.BreakingChangeResultLevel]::Error }
                    $warnings = $results | where { $_.Level -EQ [Microsoft.Azure.Connectors.BreakingChangeDetector.BreakingChangeResultLevel]::Warning }

                    if ($errors.Count -gt 0) {
                        $errorsTotal += $errors.Count
                        $errors | foreach { Write-Host "##vso[task.LogIssue type=error;]$($_.ValuePath): $($_.Message)" }
                    } # If there are any errors

                    if ($warnings.Count -gt 0) {
                        $warningsTotal += $warnings.Count
                        $warnings | foreach { Write-Host "##vso[task.LogIssue type=warning;]$($_.ValuePath): $($_.Message)" }
                    } # If there are any warnings
                    Remove-Item -Path $oldFilePath
                } # If old version of the swagger is available
            } # If previous commit exists
        } # If current file is a swagger file
    } # For each file

    if ($errorsTotal -gt 0)
    {
        Write-Host "##vso[task.complete result=Failed;]Errors encountered."    
        exit 1
    }
    elseif ($warningsTotal -gt 0)
    {
        Write-Host "##vso[task.complete result=SucceededWithIssues;]Warnings encountered."    
    }
    else
    {
        Write-Host "##vso[task.complete result=Succeeded;]No error or warnings encountered."    
    }
