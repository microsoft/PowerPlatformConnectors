{
  "definitions": {
    "AddPdfAnnotationRequest": {
      "description": "Request to add annotations to a PDF",
      "properties": {
        "AnnotationsToAdd": {
          "description": "Annotations to add to the PDF file",
          "items": {
            "$ref": "#/definitions/PdfAnnotation"
          },
          "type": "array"
        },
        "InputFileBytes": {
          "description": "Input file contents bytes for the file to modify",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "AlternateFileFormatCandidate": {
      "description": "Alternate file format possibility",
      "properties": {
        "DetectedFileExtension": {
          "description": "Detected file extension of the file format, with a leading period",
          "type": "string"
        },
        "DetectedMimeType": {
          "description": "MIME type of this file extension",
          "type": "string"
        },
        "Probability": {
          "description": "Probability that this extension is the right one; possible values are between 0.0 (lowest confidence) and 1.0 (highest confidence)",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "AutodetectDocumentValidationResult": {
      "description": "Document validation result",
      "properties": {
        "DocumentIsValid": {
          "description": "True if the document is valid and has no errors, false otherwise",
          "type": "boolean"
        },
        "ErrorCount": {
          "description": "Number of validation errors found in the document",
          "format": "int32",
          "type": "integer"
        },
        "ErrorsAndWarnings": {
          "description": "Details of errors and warnings found",
          "items": {
            "$ref": "#/definitions/DocumentValidationError"
          },
          "type": "array"
        },
        "FileFormatExtension": {
          "type": "string"
        },
        "WarningCount": {
          "description": "Number of validation warnings found in the document",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "AutodetectGetInfoResult": {
      "description": "Result of an autodetect/get-info operation",
      "properties": {
        "AlternateFileTypeCandidates": {
          "description": "Alternate file type options and their probability",
          "items": {
            "$ref": "#/definitions/AlternateFileFormatCandidate"
          },
          "type": "array"
        },
        "Author": {
          "description": "User name of the creator/author of the document, if available, null if not available",
          "type": "string"
        },
        "DateModified": {
          "description": "The timestamp that the document was last modified, if available, null if not available",
          "format": "date-time",
          "type": "string"
        },
        "DetectedFileExtension": {
          "description": "Detected file extension of the file format, with a leading period",
          "type": "string"
        },
        "DetectedMimeType": {
          "description": "MIME type of this file extension",
          "type": "string"
        },
        "PageCount": {
          "description": "Number of pages in a page-based document; for presentations, this is the number of slides and for a spreadsheet this is the number of worksheets.  Contains 0 when the page count cannot be determined, or if the concept of page count does not apply (e.g. for an image)",
          "format": "int64",
          "type": "integer"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "AutodetectToPngResult": {
      "description": "Result of converting an autodetected input to a PNG array",
      "properties": {
        "PngResultPages": {
          "description": "Array of converted pages",
          "items": {
            "$ref": "#/definitions/ConvertedPngPage"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "Base64DecodeRequest": {
      "description": "Request to decode content from Base 64 into binary",
      "properties": {
        "Base64ContentToDecode": {
          "description": "Input content to decode from Base 64 into binary",
          "type": "string"
        }
      },
      "type": "object"
    },
    "Base64DecodeResponse": {
      "description": "Result of base 64 decoding",
      "properties": {
        "ContentResult": {
          "description": "Result of performing a base 64 decode operation, binary file content",
          "format": "byte",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "Base64DetectRequest": {
      "description": "Request to detect if input content is base 64 encoded",
      "properties": {
        "Base64ContentToDetect": {
          "description": "Input content text to detect if it is base 64 encoded",
          "type": "string"
        }
      },
      "type": "object"
    },
    "Base64DetectResponse": {
      "description": "Result of base 64 detection",
      "properties": {
        "IsBase64Encoded": {
          "description": "True if the input string is base 64 encoded, false otherwise",
          "type": "boolean"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "Base64EncodeRequest": {
      "description": "Request to encode content to Base 64",
      "properties": {
        "ContentToEncode": {
          "description": "Input content to encode into Base 64",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "Base64EncodeResponse": {
      "description": "Result of base 64 encoding",
      "properties": {
        "Base64TextContentResult": {
          "description": "Result of performing a base 64 encoding operation, a text string representing the encoded original file content",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ChangeLineEndingResponse": {
      "description": "Result of performing a change line ending operation",
      "properties": {
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "TextContentResult": {
          "description": "Text content result",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ClearXlsxCellRequest": {
      "description": "Input to a Clear Cell in XLSX Worksheet request",
      "properties": {
        "CellIndex": {
          "description": "0-based index of the cell, 0, 1, 2, ... in the row to clear",
          "format": "int32",
          "type": "integer"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "RowIndex": {
          "description": "0-based index of the row, 0, 1, 2, ... to clear",
          "format": "int32",
          "type": "integer"
        },
        "WorksheetToUpdate": {
          "$ref": "#/definitions/XlsxWorksheet",
          "description": "Optional; Worksheet (tab) within the spreadsheet to update; leave blank to default to the first worksheet"
        }
      },
      "type": "object"
    },
    "ClearXlsxCellResponse": {
      "description": "Result of running a Clear XLSX Cell command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited XLSX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ConvertedPngPage": {
      "description": "A single converted page",
      "properties": {
        "PageNumber": {
          "description": "Page number of the converted page, starting with 1",
          "format": "int32",
          "type": "integer"
        },
        "URL": {
          "description": "URL to the PNG file of this page; file is stored in an in-memory cache and will be deleted",
          "type": "string"
        }
      },
      "type": "object"
    },
    "CreateBlankDocxRequest": {
      "description": "Input to a Create Blank Word Document request",
      "properties": {
        "InitialText": {
          "description": "Optional; initial text to include in the document",
          "type": "string"
        }
      },
      "type": "object"
    },
    "CreateBlankDocxResponse": {
      "description": "Result of creating a blank Word document",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited XLSX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "CreateBlankSpreadsheetRequest": {
      "description": "Input to a Create Blank Spreadsheet request",
      "properties": {
        "WorksheetName": {
          "description": "The blank Spreadsheet will have a default Worksheet in it; supply a name, or if left empty, will default to Worksheet1",
          "type": "string"
        }
      },
      "type": "object"
    },
    "CreateBlankSpreadsheetResponse": {
      "description": "Result of creating a blank worksheet",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited XLSX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "CreateSpreadsheetFromDataRequest": {
      "description": "Input to Create a new Spreadsheet request",
      "properties": {
        "Rows": {
          "description": "Required; Rows and cells to populate the spreadsheet with",
          "items": {
            "$ref": "#/definitions/XlsxSpreadsheetRow"
          },
          "type": "array"
        },
        "WorksheetName": {
          "description": "Optional; The new Spreadsheet will have a default Worksheet in it; supply a name, or if left empty, will default to Worksheet1",
          "type": "string"
        }
      },
      "type": "object"
    },
    "CreateSpreadsheetFromDataResponse": {
      "description": "Result of creating a new worksheet from rows and cells",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited XLSX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "CreateZipArchiveRequest": {
      "description": "Request to create a Zip Archive",
      "properties": {
        "DirectoriesInZip": {
          "description": "Top-level directories in the root directory of the zip; directories can contain sub-directories and files",
          "items": {
            "$ref": "#/definitions/ZipDirectory"
          },
          "type": "array"
        },
        "FilesInZip": {
          "description": "Top-level files in the root directory fo the zip file",
          "items": {
            "$ref": "#/definitions/ZipFile"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DeleteDocxTableRowRangeRequest": {
      "description": "Input to a delete DOCX table row range request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "TablePath": {
          "description": "Path to the table to delete the row from",
          "type": "string"
        },
        "TableRowRowIndexEnd": {
          "description": "0-based index of the row to stop deleting rows (e.g. 0, 1, 2, ...) in the table",
          "format": "int32",
          "type": "integer"
        },
        "TableRowRowIndexStart": {
          "description": "0-based index of the row to begin deleting rows (e.g. 0, 1, 2, ...) in the table",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DeleteDocxTableRowRangeResponse": {
      "description": "Result of running an Delete Table Row Range command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DeleteDocxTableRowRequest": {
      "description": "Input to a delete DOCX table row request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "TablePath": {
          "description": "Path to the table to delete the row from",
          "type": "string"
        },
        "TableRowRowIndex": {
          "description": "0-based index of the row to delete (e.g. 0, 1, 2, ...) in the table",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DeleteDocxTableRowResponse": {
      "description": "Result of running an Delete Table Row command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DetectLineEndingsResponse": {
      "description": "Result of base 64 decoding",
      "properties": {
        "InputLength": {
          "description": "Length of the input string in characters",
          "format": "int32",
          "type": "integer"
        },
        "PrimaryNewlineTerminator": {
          "description": "Characters used to terminate a newline; can be carriage return, linefeed, or carriage return + linefeed",
          "type": "string"
        },
        "PrimaryNewlineType": {
          "description": "Type of newline in the file; possible vlaues are \"Mac\" (legacy Mac OS uses carriage return only); \"Unix\" (Unix and Linux OSes, and modern Mac OS); \"Windows\" (Windows operating systems)",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentValidationError": {
      "description": "Validation error found in document",
      "properties": {
        "Description": {
          "description": "Description of the error",
          "type": "string"
        },
        "IsError": {
          "description": "True if this is an error, false otherwise",
          "type": "boolean"
        },
        "Path": {
          "description": "XPath to the error",
          "type": "string"
        },
        "Uri": {
          "description": "URI of the part in question",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocumentValidationResult": {
      "description": "Document validation result",
      "properties": {
        "DocumentIsValid": {
          "description": "True if the document is valid and has no errors, false otherwise",
          "type": "boolean"
        },
        "ErrorCount": {
          "description": "Number of validation errors found in the document",
          "format": "int32",
          "type": "integer"
        },
        "ErrorsAndWarnings": {
          "description": "Details of errors and warnings found",
          "items": {
            "$ref": "#/definitions/DocumentValidationError"
          },
          "type": "array"
        },
        "WarningCount": {
          "description": "Number of validation warnings found in the document",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DocxBody": {
      "properties": {
        "AllParagraphs": {
          "description": "All paragraphs anywhere in the document; these objects are not sequentially placed but are scatted across document",
          "items": {
            "$ref": "#/definitions/DocxParagraph"
          },
          "type": "array"
        },
        "AllTables": {
          "description": "All tables anywhere in the document; these objects are not sequentially placed but are scatted across the document",
          "items": {
            "$ref": "#/definitions/DocxTable"
          },
          "type": "array"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new tables",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxCellStyle": {
      "description": "Style in an Excel spreadsheet",
      "properties": {
        "BuiltInID": {
          "description": "Built=in ID of the cell style",
          "format": "int32",
          "type": "integer"
        },
        "FormatID": {
          "description": "Format ID of the cell style",
          "format": "int32",
          "type": "integer"
        },
        "Name": {
          "description": "Name of the style",
          "type": "string"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new rows",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxComment": {
      "description": "Comment in a Word Document",
      "properties": {
        "Author": {
          "description": "Author name of the comment",
          "type": "string"
        },
        "AuthorInitials": {
          "description": "Initials of the author of the comment",
          "type": "string"
        },
        "CommentDate": {
          "description": "Date timestamp of the comment",
          "format": "date-time",
          "type": "string"
        },
        "CommentText": {
          "description": "Text content of the comment",
          "type": "string"
        },
        "Done": {
          "description": "True if this comment is marked as Done in Word, otherwise it is false",
          "type": "boolean"
        },
        "IsReply": {
          "description": "True if this comment is a reply to another comment, false otherwise",
          "type": "boolean"
        },
        "IsTopLevel": {
          "description": "True if the comment is at the top level, false if this comment is a child reply of another comment",
          "type": "boolean"
        },
        "ParentCommentPath": {
          "description": "Path to the parent of this comment, if this comment is a reply, otherwise this value will be null",
          "type": "string"
        },
        "Path": {
          "description": "Path to the comment in the document",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxFooter": {
      "description": "Footer in a Word Document (DOCX)",
      "properties": {
        "Paragraphs": {
          "description": "Paragraphs in this footer",
          "items": {
            "$ref": "#/definitions/DocxParagraph"
          },
          "type": "array"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new tables",
          "type": "string"
        },
        "SectionsWithFooter": {
          "description": "Sections that the footer is applied to",
          "items": {
            "$ref": "#/definitions/DocxSection"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DocxHeader": {
      "description": "Header of a Word Document (DOCX)",
      "properties": {
        "Paragraphs": {
          "description": "Paragraphs in this header",
          "items": {
            "$ref": "#/definitions/DocxParagraph"
          },
          "type": "array"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new tables",
          "type": "string"
        },
        "SectionsWithHeader": {
          "description": "Sections that the header is applied to",
          "items": {
            "$ref": "#/definitions/DocxSection"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DocxImage": {
      "properties": {
        "ImageContentsURL": {
          "description": "URL to the image contents; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the contents.",
          "type": "string"
        },
        "ImageDataContentType": {
          "description": "Read-only; image data MIME content-type",
          "type": "string"
        },
        "ImageDataEmbedId": {
          "description": "Read-only; internal ID for the image contents",
          "type": "string"
        },
        "ImageDescription": {
          "description": "The Description of the image",
          "type": "string"
        },
        "ImageHeight": {
          "description": "Height of the image in EMUs (English Metric Units); set to 0 to default to page width and aspect-ratio based height",
          "format": "int64",
          "type": "integer"
        },
        "ImageId": {
          "description": "The Id of the image",
          "format": "int64",
          "type": "integer"
        },
        "ImageInternalFileName": {
          "description": "Read-only; internal file name/path for the image",
          "type": "string"
        },
        "ImageName": {
          "description": "The Name of the image",
          "type": "string"
        },
        "ImageWidth": {
          "description": "Width of the image in EMUs (English Metric Units); set to 0 to default to page width and aspect-ratio based height",
          "format": "int64",
          "type": "integer"
        },
        "InlineWithText": {
          "description": "True if the image is inline with the text; false if it is floating",
          "type": "boolean"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new tables",
          "type": "string"
        },
        "XOffset": {
          "description": "X (horizontal) offset of the image",
          "format": "int64",
          "type": "integer"
        },
        "YOffset": {
          "description": "Y (vertical) offset of the image",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DocxInsertCommentOnParagraphRequest": {
      "description": "Input to a Insert Comment on Paragraph request",
      "properties": {
        "CommentToInsert": {
          "$ref": "#/definitions/DocxComment",
          "description": "Comment to insert"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "ParagraphPath": {
          "description": "Path to the paragraph to attach the comment to.  You can get the Path by retrieving all of the Paragraphs in document by calling Get Body and taking the Path property of the desired paragraph to add the comment to.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxInsertImageRequest": {
      "description": "Input to set-footer command",
      "properties": {
        "HeightInEMUs": {
          "description": "Optional: The height of the image in EMUs",
          "format": "int64",
          "type": "integer"
        },
        "ImageToAdd": {
          "$ref": "#/definitions/DocxImage",
          "description": "Optional: Image to add; if you supply in this object, do not supply InputImageFileBytes or InputImageFileUrl."
        },
        "InputDocumentFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputDocumentFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "InputImageFileBytes": {
          "description": "Optional: Bytes of the input image file to operate on; if you supply this value do not supply InputImageFileUrl or ImageToAdd.",
          "format": "byte",
          "type": "string"
        },
        "InputImageFileUrl": {
          "description": "Optional: URL of an image file to operate on as input; if you supply this value do not supply InputImageFileBytes or ImageToAdd.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "InsertPath": {
          "description": "Optional; location within the document to insert the object; fill in the InsertPath field using the Path value from an existing object.  Used with InsertPlacement of BeforeExistingObject or AfterExistingObject",
          "type": "string"
        },
        "InsertPlacement": {
          "description": "Optional; default is DocumentEnd.  Placement Type of the insert; possible values are: DocumentStart (very beginning of the document), DocumentEnd (very end of the document), BeforeExistingObject (right before an existing object - fill in the InsertPath field using the Path value from an existing object), AfterExistingObject (right after an existing object - fill in the InsertPath field using the Path value from an existing object)",
          "type": "string"
        },
        "WidthInEMUs": {
          "description": "Optional: The width of the image in EMUs",
          "format": "int64",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DocxInsertImageResponse": {
      "description": "Result of running a set-footer command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocxPage": {
      "description": "One page in a Word Document DOCX",
      "properties": {
        "PageNumber": {
          "description": "Page number of this page, 1-based",
          "format": "int32",
          "type": "integer"
        },
        "Paragraphs": {
          "description": "All paragraphs anywhere in the document; these objects are not sequentially placed but are scatted across document",
          "items": {
            "$ref": "#/definitions/DocxParagraph"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DocxParagraph": {
      "description": "A paragraph in a Word Document (DOCX) file; there is where text, content and formatting are stored - similar to the paragraph tag in HTML",
      "properties": {
        "ContentRuns": {
          "description": "The content runs in the paragraph - this is where text is stored; similar to a span in HTML",
          "items": {
            "$ref": "#/definitions/DocxRun"
          },
          "type": "array"
        },
        "ParagraphIndex": {
          "description": "The index of the paragraph; 0-based",
          "format": "int32",
          "type": "integer"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new tables",
          "type": "string"
        },
        "StyleID": {
          "description": "Style ID of the style applied to the paragraph; null if no style is applied",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxRemoveObjectRequest": {
      "description": "Input to a Insert Paragraph request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "PathToObjectToRemove": {
          "description": "Path within the document of the object to delete; fill in the PathToObjectToRemove field using the Path value from an existing object.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxRemoveObjectResponse": {
      "description": "Result of running an Remove-Object command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocxRun": {
      "description": "A content run in a Word Document (DOCX) file",
      "properties": {
        "Bold": {
          "description": "True to make the text bold, false otherwise",
          "type": "boolean"
        },
        "FontFamily": {
          "description": "Font Family name for the text, e.g. \"Arial\" or \"Times New Roman\"",
          "type": "string"
        },
        "FontSize": {
          "description": "Font size in font points (e.g. \"24\")",
          "type": "string"
        },
        "Italic": {
          "description": "True to make the text italic, false otherwise",
          "type": "boolean"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new tables",
          "type": "string"
        },
        "RunIndex": {
          "description": "Index of the run, 0-based",
          "format": "int32",
          "type": "integer"
        },
        "TextItems": {
          "description": "Text items inside the run; this is where the actual text content is stored",
          "items": {
            "$ref": "#/definitions/DocxText"
          },
          "type": "array"
        },
        "Underline": {
          "description": "Underline mode for the text; possible values are: Words, Double, Thick, Dotted, DottedHeavy, Dash, DashedHeavy, DashLong, DashLongHeavy, DotDash, DashDotHeavy, DotDotDash, DashDotDotHeavy, Wave, WavyHeavy, WavyDouble, None",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxSection": {
      "description": "Section of a Word Document (DOCX)",
      "properties": {
        "Path": {
          "description": "The Path of the location of this object; leave blank for new tables",
          "type": "string"
        },
        "StartingPageNumbers": {
          "description": "Page numbers that the section starts at, typically just one",
          "items": {
            "format": "int32",
            "type": "integer"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DocxSetFooterAddPageNumberRequest": {
      "description": "Input to set-footer/add-page-number command",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "PrependText": {
          "description": "Optional: extra text to add before the page number, for example if you want to show \"Page 1\" then you can set PrependText to \"Page\"",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxSetFooterRequest": {
      "description": "Input to set-footer command",
      "properties": {
        "FooterToApply": {
          "$ref": "#/definitions/DocxFooter",
          "description": "Footer to apply"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxSetFooterResponse": {
      "description": "Result of running a set-footer command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocxSetHeaderRequest": {
      "description": "Input to a set-header command",
      "properties": {
        "HeaderToApply": {
          "$ref": "#/definitions/DocxHeader",
          "description": "Header to apply"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxSetHeaderResponse": {
      "description": "Result of running a set-header command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocxStyle": {
      "description": "Style in a DOCX Word Document",
      "properties": {
        "Bold": {
          "description": "Style applies bold formatting",
          "type": "boolean"
        },
        "FontFamily": {
          "description": "Font family",
          "type": "string"
        },
        "FontSize": {
          "description": "Font size",
          "type": "string"
        },
        "Italic": {
          "description": "Style applies italic formatting",
          "type": "boolean"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new tables",
          "type": "string"
        },
        "StyleID": {
          "description": "ID of the style",
          "type": "string"
        },
        "Underline": {
          "description": "Style applies underline formatting",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocxTable": {
      "description": "A table in a Word Document (DOCX) file",
      "properties": {
        "BottomBorderColor": {
          "description": "HTML-style color hex value (do not include a #)",
          "type": "string"
        },
        "BottomBorderSize": {
          "description": "Width of the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "BottomBorderSpace": {
          "description": "Spacing around the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "BottomBorderType": {
          "description": "Type for the bottom border - can be a Single, DashDotStroked, Dashed, DashSmallGap, DotDash, DotDotDash, Dotted, Double, DoubleWave, Inset, Nil, None, Outset, Thick, ThickThinLargeGap, ThickThinMediumGap, ThickThinSmallGap, ThinThickLargeGap, ThinThickMediumGap, ThinThickSmallGap, ThinThickThinLargeGap, ThinThickThinMediumGap, ThinThickThinSmallGap, ThreeDEmboss, ThreeDEngrave, Triple, Wave",
          "type": "string"
        },
        "CellHorizontalBorderColor": {
          "description": "HTML-style color hex value (do not include a #)",
          "type": "string"
        },
        "CellHorizontalBorderSize": {
          "description": "Width of the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "CellHorizontalBorderSpace": {
          "description": "Spacing around the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "CellHorizontalBorderType": {
          "description": "Type for the cell horizontal border - can be a Single, DashDotStroked, Dashed, DashSmallGap, DotDash, DotDotDash, Dotted, Double, DoubleWave, Inset, Nil, None, Outset, Thick, ThickThinLargeGap, ThickThinMediumGap, ThickThinSmallGap, ThinThickLargeGap, ThinThickMediumGap, ThinThickSmallGap, ThinThickThinLargeGap, ThinThickThinMediumGap, ThinThickThinSmallGap, ThreeDEmboss, ThreeDEngrave, Triple, Wave",
          "type": "string"
        },
        "CellVerticalBorderColor": {
          "description": "HTML-style color hex value (do not include a #)",
          "type": "string"
        },
        "CellVerticalBorderSize": {
          "description": "Width of the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "CellVerticalBorderSpace": {
          "description": "Spacing around the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "CellVerticalBorderType": {
          "description": "Type for the cell vertical border - can be a Single, DashDotStroked, Dashed, DashSmallGap, DotDash, DotDotDash, Dotted, Double, DoubleWave, Inset, Nil, None, Outset, Thick, ThickThinLargeGap, ThickThinMediumGap, ThickThinSmallGap, ThinThickLargeGap, ThinThickMediumGap, ThinThickSmallGap, ThinThickThinLargeGap, ThinThickThinMediumGap, ThinThickThinSmallGap, ThreeDEmboss, ThreeDEngrave, Triple, Wave",
          "type": "string"
        },
        "EndBorderColor": {
          "description": "HTML-style color hex value (do not include a #)",
          "type": "string"
        },
        "EndBorderSize": {
          "description": "Width of the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "EndBorderSpace": {
          "description": "Spacing around the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "EndBorderType": {
          "description": "Type for the end border - can be a Single, DashDotStroked, Dashed, DashSmallGap, DotDash, DotDotDash, Dotted, Double, DoubleWave, Inset, Nil, None, Outset, Thick, ThickThinLargeGap, ThickThinMediumGap, ThickThinSmallGap, ThinThickLargeGap, ThinThickMediumGap, ThinThickSmallGap, ThinThickThinLargeGap, ThinThickThinMediumGap, ThinThickThinSmallGap, ThreeDEmboss, ThreeDEngrave, Triple, Wave",
          "type": "string"
        },
        "LeftBorderColor": {
          "description": "HTML-style color hex value (do not include a #)",
          "type": "string"
        },
        "LeftBorderSize": {
          "description": "Width of the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "LeftBorderSpace": {
          "description": "Spacing around the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "LeftBorderType": {
          "description": "Type for the left border - can be a Single, DashDotStroked, Dashed, DashSmallGap, DotDash, DotDotDash, Dotted, Double, DoubleWave, Inset, Nil, None, Outset, Thick, ThickThinLargeGap, ThickThinMediumGap, ThickThinSmallGap, ThinThickLargeGap, ThinThickMediumGap, ThinThickSmallGap, ThinThickThinLargeGap, ThinThickThinMediumGap, ThinThickThinSmallGap, ThreeDEmboss, ThreeDEngrave, Triple, Wave",
          "type": "string"
        },
        "Path": {
          "description": "The Path of the location of this table object; leave blank for new tables",
          "type": "string"
        },
        "RightBorderColor": {
          "description": "HTML-style color hex value (do not include a #)",
          "type": "string"
        },
        "RightBorderSize": {
          "description": "Width of the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "RightBorderSpace": {
          "description": "Spacing around the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "RightBorderType": {
          "description": "Type for the right border - can be a Single, DashDotStroked, Dashed, DashSmallGap, DotDash, DotDotDash, Dotted, Double, DoubleWave, Inset, Nil, None, Outset, Thick, ThickThinLargeGap, ThickThinMediumGap, ThickThinSmallGap, ThinThickLargeGap, ThinThickMediumGap, ThinThickSmallGap, ThinThickThinLargeGap, ThinThickThinMediumGap, ThinThickThinSmallGap, ThreeDEmboss, ThreeDEngrave, Triple, Wave",
          "type": "string"
        },
        "StartBorderColor": {
          "description": "HTML-style color hex value (do not include a #)",
          "type": "string"
        },
        "StartBorderSize": {
          "description": "Width of the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "StartBorderSpace": {
          "description": "Spacing around the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "StartBorderType": {
          "description": "Type for the start border - can be a Single, DashDotStroked, Dashed, DashSmallGap, DotDash, DotDotDash, Dotted, Double, DoubleWave, Inset, Nil, None, Outset, Thick, ThickThinLargeGap, ThickThinMediumGap, ThickThinSmallGap, ThinThickLargeGap, ThinThickMediumGap, ThinThickSmallGap, ThinThickThinLargeGap, ThinThickThinMediumGap, ThinThickThinSmallGap, ThreeDEmboss, ThreeDEngrave, Triple, Wave",
          "type": "string"
        },
        "TableID": {
          "description": "The ID of the table; leave blank for new tables",
          "type": "string"
        },
        "TableIndentationMode": {
          "description": "Table indentation type",
          "type": "string"
        },
        "TableIndentationWidth": {
          "description": "Table indentation width",
          "format": "int32",
          "type": "integer"
        },
        "TableRows": {
          "description": "Rows in the table; this is where the contents is located",
          "items": {
            "$ref": "#/definitions/DocxTableRow"
          },
          "type": "array"
        },
        "TopBorderColor": {
          "description": "HTML-style color hex value (do not include a #)",
          "type": "string"
        },
        "TopBorderSize": {
          "description": "Width of the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "TopBorderSpace": {
          "description": "Spacing around the border in points (1/72nd of an inch)",
          "format": "int32",
          "type": "integer"
        },
        "TopBorderType": {
          "description": "Type for the top border - can be a Single, DashDotStroked, Dashed, DashSmallGap, DotDash, DotDotDash, Dotted, Double, DoubleWave, Inset, Nil, None, Outset, Thick, ThickThinLargeGap, ThickThinMediumGap, ThickThinSmallGap, ThinThickLargeGap, ThinThickMediumGap, ThinThickSmallGap, ThinThickThinLargeGap, ThinThickThinMediumGap, ThinThickThinSmallGap, ThreeDEmboss, ThreeDEngrave, Triple, Wave",
          "type": "string"
        },
        "Width": {
          "description": "The Width of the table, or 0 if not specified",
          "type": "string"
        },
        "WidthType": {
          "description": "The Width configuration type of the table",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxTableCell": {
      "description": "A cell in a Word Document (DOCX) file",
      "properties": {
        "CellIndex": {
          "description": "The index of the cell, 0-based",
          "format": "int32",
          "type": "integer"
        },
        "CellShadingColor": {
          "description": "Color of the cell shading",
          "type": "string"
        },
        "CellShadingFill": {
          "description": "Fill of the cell shading",
          "type": "string"
        },
        "CellShadingPattern": {
          "description": "Pattern of the cell shading",
          "type": "string"
        },
        "CellWidth": {
          "description": "Width of the cell",
          "type": "string"
        },
        "CellWidthMode": {
          "description": "Width mode of the cell; can be auto (for automatic) or manual",
          "type": "string"
        },
        "Paragraphs": {
          "description": "Paragraphs inside the cell; this is where the contents of the cell are stored",
          "items": {
            "$ref": "#/definitions/DocxParagraph"
          },
          "type": "array"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new tables",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxTableRow": {
      "description": "A row in a Word Document (DOCX) file",
      "properties": {
        "Path": {
          "description": "The Path of the location of this table row object; leave blank for new tables",
          "type": "string"
        },
        "RowCells": {
          "description": "Cells in the row; this is where the contents of the row is stored",
          "items": {
            "$ref": "#/definitions/DocxTableCell"
          },
          "type": "array"
        },
        "RowIndex": {
          "description": "Index of the row, 0-based",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DocxTemplateApplicationRequest": {
      "description": "Word DOCX template application request",
      "properties": {
        "Operations": {
          "description": "Operations to apply to this template",
          "items": {
            "$ref": "#/definitions/DocxTemplateOperation"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "DocxTemplateOperation": {
      "properties": {
        "Action": {
          "description": "Operation action to take; possible values are \"Replace\"",
          "enum": [
            1
          ],
          "format": "int32",
          "type": "integer"
        },
        "MatchAgainst": {
          "description": "For Replace operations, the string to match against (to be replaced with ReplaceWith string)",
          "type": "string"
        },
        "ReplaceWith": {
          "description": "For Replace operations, the string to Replace the original string with",
          "type": "string"
        }
      },
      "type": "object"
    },
    "DocxText": {
      "description": "Unit of text content in a Word Document (DOCX) file",
      "properties": {
        "Path": {
          "description": "The Path of the location of this object; leave blank for new tables",
          "type": "string"
        },
        "TextContent": {
          "description": "Text string containing the text content of this text content item",
          "type": "string"
        },
        "TextIndex": {
          "description": "Index of the text content in the run; 0-based",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "DocxTopLevelComment": {
      "description": "Top-level Comment in a Word Document",
      "properties": {
        "Author": {
          "description": "Author name of the comment",
          "type": "string"
        },
        "AuthorInitials": {
          "description": "Initials of the author of the comment",
          "type": "string"
        },
        "CommentDate": {
          "description": "Date timestamp of the comment",
          "format": "date-time",
          "type": "string"
        },
        "CommentText": {
          "description": "Text content of the comment",
          "type": "string"
        },
        "Done": {
          "description": "True if this comment is marked as Done in Word, otherwise it is false",
          "type": "boolean"
        },
        "Path": {
          "description": "Path to the comment in the document",
          "type": "string"
        },
        "ReplyChildComments": {
          "description": "Child comments, that are replies to this one",
          "items": {
            "$ref": "#/definitions/DocxComment"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ExifValue": {
      "description": "EXIF tag and value",
      "properties": {
        "DataType": {
          "description": "Date type of the EXIF value",
          "type": "string"
        },
        "DataValue": {
          "description": "Value, formatted as a string of the EXIF value",
          "type": "string"
        },
        "Tag": {
          "description": "Tag name for the EXIF value",
          "type": "string"
        }
      },
      "type": "object"
    },
    "FindRegexMatch": {
      "description": "Individual regular expression match result of finding a target regex in a longer text string",
      "properties": {
        "CharacterOffsetEnd": {
          "description": "0-based index of the end of the match",
          "format": "int32",
          "type": "integer"
        },
        "CharacterOffsetStart": {
          "description": "0-based index of the start of the match",
          "format": "int32",
          "type": "integer"
        },
        "ContainingLine": {
          "description": "Text content of the line containing the match",
          "type": "string"
        },
        "MatchGroups": {
          "description": "Regular expression regex match groups; these correspond to the match values",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "MatchValue": {
          "description": "The match value",
          "type": "string"
        }
      },
      "type": "object"
    },
    "FindStringMatch": {
      "description": "Individual match result of finding a target string in a longer text string",
      "properties": {
        "CharacterOffsetEnd": {
          "description": "0-based index of the end of the match",
          "format": "int32",
          "type": "integer"
        },
        "CharacterOffsetStart": {
          "description": "0-based index of the start of the match",
          "format": "int32",
          "type": "integer"
        },
        "ContainingLine": {
          "description": "Text content of the line containing the match",
          "type": "string"
        }
      },
      "type": "object"
    },
    "FindStringRegexRequest": {
      "description": "Request to find a string in a string",
      "properties": {
        "MatchCase": {
          "description": "Set to True to match case, False to ignore case",
          "type": "boolean"
        },
        "TargetRegex": {
          "description": "Target input regular expression (regex) to find",
          "type": "string"
        },
        "TextContent": {
          "description": "Input text content",
          "type": "string"
        }
      },
      "type": "object"
    },
    "FindStringRegexResponse": {
      "description": "Result of finding a string",
      "properties": {
        "MatchCount": {
          "description": "The number of matches",
          "format": "int32",
          "type": "integer"
        },
        "Matches": {
          "description": "Regular expression matches",
          "items": {
            "$ref": "#/definitions/FindRegexMatch"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "FindStringSimpleRequest": {
      "description": "Request to find a string in a string",
      "properties": {
        "TargetString": {
          "description": "Target input string to find",
          "type": "string"
        },
        "TextContent": {
          "description": "Input text content",
          "type": "string"
        }
      },
      "type": "object"
    },
    "FindStringSimpleResponse": {
      "description": "Result of finding a string",
      "properties": {
        "MatchCount": {
          "description": "The number of matches",
          "format": "int32",
          "type": "integer"
        },
        "Matches": {
          "description": "Found matches",
          "items": {
            "$ref": "#/definitions/FindStringMatch"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "FinishEditingRequest": {
      "description": "Input to a Finish Editing request",
      "properties": {
        "InputFileUrl": {
          "description": "URL of a document being edited to get the contents of.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetDocxBodyRequest": {
      "description": "Input to a Get Body request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetDocxBodyResponse": {
      "description": "Result of running a Get-Body command",
      "properties": {
        "Body": {
          "$ref": "#/definitions/DocxBody",
          "description": "Body in the DOCX document"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetDocxCommentsHierarchicalResponse": {
      "description": "Result of getting comments hierarchically from a Word Document DOCX",
      "properties": {
        "Comments": {
          "description": "Comments in the document",
          "items": {
            "$ref": "#/definitions/DocxTopLevelComment"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "TopLevelCommentCount": {
          "description": "The number of comments in the document",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "GetDocxCommentsResponse": {
      "description": "Result of getting comments from a Word Document DOCX",
      "properties": {
        "CommentCount": {
          "description": "The number of comments in the document",
          "format": "int32",
          "type": "integer"
        },
        "Comments": {
          "description": "Comments in the document",
          "items": {
            "$ref": "#/definitions/DocxComment"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetDocxGetCommentsHierarchicalRequest": {
      "description": "Input to a Get Word DOCX Document comments hierarchically request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetDocxGetCommentsRequest": {
      "description": "Input to a Get Word DOCX Document comments request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetDocxHeadersAndFootersRequest": {
      "description": "Input to a Get Tables request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetDocxHeadersAndFootersResponse": {
      "description": "Result of running a Get-Tables command",
      "properties": {
        "Footers": {
          "items": {
            "$ref": "#/definitions/DocxFooter"
          },
          "type": "array"
        },
        "Headers": {
          "items": {
            "$ref": "#/definitions/DocxHeader"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetDocxImagesRequest": {
      "description": "Input to a Get Images request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetDocxImagesResponse": {
      "description": "Result of running a Get-Images command",
      "properties": {
        "Images": {
          "description": "Images in the DOCX document",
          "items": {
            "$ref": "#/definitions/DocxImage"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetDocxPagesRequest": {
      "description": "Input to a Get Word DOCX Document Pages request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetDocxPagesResponse": {
      "description": "Result of getting pages from a Word Document DOCX",
      "properties": {
        "PageCount": {
          "description": "Count of pages",
          "format": "int32",
          "type": "integer"
        },
        "Pages": {
          "description": "Pages in the document",
          "items": {
            "$ref": "#/definitions/DocxPage"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetDocxSectionsRequest": {
      "description": "Input to a Get Sections request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetDocxSectionsResponse": {
      "description": "Result of running a Get-Sections command",
      "properties": {
        "Sections": {
          "description": "Sections in the DOCX document",
          "items": {
            "$ref": "#/definitions/DocxSection"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetDocxStylesRequest": {
      "description": "Input to a Get Tables request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetDocxStylesResponse": {
      "description": "Result of running a Get-Tables command",
      "properties": {
        "Styles": {
          "description": "Styles in the DOCX document",
          "items": {
            "$ref": "#/definitions/DocxStyle"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetDocxTableByIndexRequest": {
      "description": "Input to a Get Tables by Index request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "TableIndex": {
          "description": "0-based index of the table to retrieve from the Word Document",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "GetDocxTableByIndexResponse": {
      "description": "Result of running a Get-Tables by Index command",
      "properties": {
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "Table": {
          "$ref": "#/definitions/DocxTable",
          "description": "Requested Table in the DOCX file"
        }
      },
      "type": "object"
    },
    "GetDocxTableRowRequest": {
      "description": "Input to a get DOCX table row request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "TablePath": {
          "description": "Path to the table to retrievew the row from",
          "type": "string"
        },
        "TableRowRowIndex": {
          "description": "0-based index of the row to retrieve (e.g. 0, 1, 2, ...) in the table",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "GetDocxTableRowResponse": {
      "description": "Result of running an Get Table Row command",
      "properties": {
        "RowResult": {
          "$ref": "#/definitions/DocxTableRow",
          "description": "Contents of the table row that was requested"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetDocxTablesRequest": {
      "description": "Input to a Get Tables request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetDocxTablesResponse": {
      "description": "Result of running a Get-Tables command",
      "properties": {
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "Tables": {
          "description": "Tables in the DOCX file",
          "items": {
            "$ref": "#/definitions/DocxTable"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "GetImageInfoResult": {
      "description": "Result of running a get-info operation on an image",
      "properties": {
        "BitDepth": {
          "description": "Bit depth of the image",
          "format": "int32",
          "type": "integer"
        },
        "ColorCount": {
          "description": "Unique colors in the image",
          "format": "int32",
          "type": "integer"
        },
        "ColorSpace": {
          "description": "Color space of the image",
          "type": "string"
        },
        "ColorType": {
          "description": "Color type of the image",
          "type": "string"
        },
        "Comment": {
          "description": "Comment string in the image",
          "type": "string"
        },
        "CompressionLevel": {
          "description": "Compression level value from 0 (lowest quality) to 100 (highest quality)",
          "format": "int32",
          "type": "integer"
        },
        "DPI": {
          "description": "DPI (pixels per unit, e.g. pixels per inch) of the image",
          "format": "double",
          "type": "number"
        },
        "DPIUnit": {
          "description": "Units of the DPI measurement; can be either in Inches or Centimeters",
          "type": "string"
        },
        "ExifProfileName": {
          "description": "Name of the EXIF profile used",
          "type": "string"
        },
        "ExifValues": {
          "description": "EXIF tags and values embedded in the image",
          "items": {
            "$ref": "#/definitions/ExifValue"
          },
          "type": "array"
        },
        "HasTransparency": {
          "description": "True if the image contains transparency, otherwise false",
          "type": "boolean"
        },
        "Height": {
          "description": "Height in pixels of the image",
          "format": "int32",
          "type": "integer"
        },
        "ImageFormat": {
          "description": "Image format",
          "type": "string"
        },
        "ImageHashSignature": {
          "description": "SHA256 hash signature of the image",
          "type": "string"
        },
        "MimeType": {
          "description": "MIME type of the image format",
          "type": "string"
        },
        "Successful": {
          "type": "boolean"
        },
        "Width": {
          "description": "Width in pixels of the image",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "GetPdfAnnotationsResult": {
      "description": "Result of retrieving annotations from a PDF document",
      "properties": {
        "Annotations": {
          "description": "Annotations in the PDF file, ordered by placement from start to finish in the document",
          "items": {
            "$ref": "#/definitions/PdfAnnotation"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetXlsxCellByIdentifierRequest": {
      "description": "Input to a Get Cell by cell identifier request",
      "properties": {
        "CellIdentifier": {
          "description": "Required; Excel cell identifier, e.g. A1, B22, C33, etc.",
          "type": "string"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "WorksheetToQuery": {
          "$ref": "#/definitions/XlsxWorksheet",
          "description": "Optional; Worksheet (tab) within the spreadsheet to get the rows and cells of; leave blank to default to the first worksheet"
        }
      },
      "type": "object"
    },
    "GetXlsxCellByIdentifierResponse": {
      "description": "Result of running a Get-Cell command",
      "properties": {
        "Cell": {
          "$ref": "#/definitions/XlsxSpreadsheetCell",
          "description": "Requested Cell in the Excel XLSX document"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetXlsxCellRequest": {
      "description": "Input to a Get Cell request",
      "properties": {
        "CellIndex": {
          "description": "0-based index of the cell, 0, 1, 2, ... in the row to retrieve",
          "format": "int32",
          "type": "integer"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "RowIndex": {
          "description": "0-based index of the row, 0, 1, 2, ... to retrieve",
          "format": "int32",
          "type": "integer"
        },
        "WorksheetToQuery": {
          "$ref": "#/definitions/XlsxWorksheet",
          "description": "Optional; Worksheet (tab) within the spreadsheet to get the rows and cells of; leave blank to default to the first worksheet"
        }
      },
      "type": "object"
    },
    "GetXlsxCellResponse": {
      "description": "Result of running a Get-Cell command",
      "properties": {
        "Cell": {
          "$ref": "#/definitions/XlsxSpreadsheetCell",
          "description": "Requested Cell in the Excel XLSX document"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetXlsxColumnsRequest": {
      "description": "Input to a Get Columns request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "WorksheetToQuery": {
          "$ref": "#/definitions/XlsxWorksheet",
          "description": "Optional; Worksheet (tab) within the spreadsheet to get the columns of; leave blank to default to the first worksheet"
        }
      },
      "type": "object"
    },
    "GetXlsxColumnsResponse": {
      "description": "Result of running a Get-Columns command",
      "properties": {
        "Columns": {
          "description": "Spreadsheet Columns in the XLSX document",
          "items": {
            "$ref": "#/definitions/XlsxSpreadsheetColumn"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetXlsxImagesRequest": {
      "description": "Input to a Get Images request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "WorksheetToQuery": {
          "$ref": "#/definitions/XlsxWorksheet",
          "description": "Optional; Worksheet (tab) within the spreadsheet to get the images of; leave blank to default to the first worksheet"
        }
      },
      "type": "object"
    },
    "GetXlsxImagesResponse": {
      "description": "Result of running a Get-Images command",
      "properties": {
        "Images": {
          "description": "Spreadsheet Images in the XLSX document",
          "items": {
            "$ref": "#/definitions/XlsxImage"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetXlsxRowsAndCellsRequest": {
      "description": "Input to a Get Worksheets request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "WorksheetToQuery": {
          "$ref": "#/definitions/XlsxWorksheet",
          "description": "Optional; Worksheet (tab) within the spreadsheet to get the rows and cells of; leave blank to default to the first worksheet"
        }
      },
      "type": "object"
    },
    "GetXlsxRowsAndCellsResponse": {
      "description": "Result of running a Get-Worksheets command",
      "properties": {
        "Rows": {
          "description": "Spreadsheet Rows in the Excel XLSX document",
          "items": {
            "$ref": "#/definitions/XlsxSpreadsheetRow"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetXlsxStylesRequest": {
      "description": "Input to a Get Worksheets request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetXlsxStylesResponse": {
      "description": "Result of running a Get-Worksheets command",
      "properties": {
        "CellStyles": {
          "description": "Cell styles",
          "items": {
            "$ref": "#/definitions/DocxCellStyle"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "GetXlsxWorksheetsRequest": {
      "description": "Input to a Get Worksheets request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        }
      },
      "type": "object"
    },
    "GetXlsxWorksheetsResponse": {
      "description": "Result of running a Get-Worksheets command",
      "properties": {
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "Worksheets": {
          "description": "Worksheets in the Excel XLSX spreadsheet",
          "items": {
            "$ref": "#/definitions/XlsxWorksheet"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "HtmlMdResult": {
      "description": "Result from converting a Markdown file to HTML",
      "properties": {
        "Html": {
          "description": "Resulting HTML from the conversion",
          "type": "string"
        },
        "Successful": {
          "description": "True if operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "HtmlTemplateApplicationRequest": {
      "description": "HTML template application request",
      "properties": {
        "HtmlTemplate": {
          "description": "HTML template input as a string",
          "type": "string"
        },
        "HtmlTemplateUrl": {
          "description": "URL to HTML template input",
          "type": "string"
        },
        "Operations": {
          "description": "Operations to apply to this template",
          "items": {
            "$ref": "#/definitions/HtmlTemplateOperation"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "HtmlTemplateApplicationResponse": {
      "description": "Response from an HTML template application",
      "properties": {
        "FinalHtml": {
          "description": "Final HTML result of all operations on input",
          "type": "string"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "HtmlTemplateOperation": {
      "properties": {
        "Action": {
          "description": "Operation action to take; possible values are \"Replace\"",
          "enum": [
            1
          ],
          "format": "int32",
          "type": "integer"
        },
        "MatchAgsint": {
          "description": "For Replace operations, the string to match against (to be replaced with ReplaceWith string)",
          "type": "string"
        },
        "ReplaceWith": {
          "description": "For Replace operations, the string to Replace the original string with",
          "type": "string"
        }
      },
      "type": "object"
    },
    "HtmlToOfficeRequest": {
      "description": "Details of the HTML to Office request",
      "properties": {
        "Html": {
          "description": "HTML to render to Office format",
          "type": "string"
        }
      },
      "type": "object"
    },
    "HtmlToPdfRequest": {
      "description": "Details of the HTML to PDF request",
      "properties": {
        "ExtraLoadingWait": {
          "description": "Optional: Additional number of milliseconds to wait once the web page has finished loading before taking the screenshot.  Can be helpful for highly asynchronous websites.",
          "format": "int32",
          "type": "integer"
        },
        "Html": {
          "description": "HTML to render to PDF",
          "type": "string"
        }
      },
      "type": "object"
    },
    "HtmlToPngRequest": {
      "description": "Details of the HTML to PNG request",
      "properties": {
        "ExtraLoadingWait": {
          "description": "Optional: Additional number of milliseconds to wait once the web page has finished loading before taking the screenshot.  Can be helpful for highly asynchronous websites.",
          "format": "int32",
          "type": "integer"
        },
        "Html": {
          "description": "HTML to render to PNG (screenshot)",
          "type": "string"
        },
        "ScreenshotHeight": {
          "description": "Optional: Height of the screenshot in pixels; supply 0 to default to 1280 x 1024, supply -1 to measure the full screen height of the page and attempt to take a screen-height screenshot",
          "format": "int32",
          "type": "integer"
        },
        "ScreenshotWidth": {
          "description": "Optional: Width of the screenshot in pixels; supply 0 to default to 1280 x 1024, supply -1 to measure the full screen height of the page and attempt to take a screen-height screenshot",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "HtmlToTextRequest": {
      "description": "Details of the HTML to Text request",
      "properties": {
        "Html": {
          "description": "HTML to extract the text from",
          "type": "string"
        }
      },
      "type": "object"
    },
    "HtmlToTextResponse": {
      "description": "Result of running the HTML to Text operation",
      "properties": {
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "TextContentResult": {
          "description": "Text content result from the HTML input",
          "type": "string"
        }
      },
      "type": "object"
    },
    "InsertDocxCommentOnParagraphResponse": {
      "description": "Result of running an Insert-Comment-on-Paragraph command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "InsertDocxInsertParagraphRequest": {
      "description": "Input to a Insert Paragraph request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "InsertPath": {
          "description": "Optional; location within the document to insert the object; fill in the InsertPath field using the Path value from an existing object.  Used with InsertPlacement of BeforeExistingObject or AfterExistingObject",
          "type": "string"
        },
        "InsertPlacement": {
          "description": "Optional; default is DocumentEnd.  Placement Type of the insert; possible values are: DocumentStart (very beginning of the document), DocumentEnd (very end of the document), BeforeExistingObject (right before an existing object - fill in the InsertPath field using the Path value from an existing object), AfterExistingObject (right after an existing object - fill in the InsertPath field using the Path value from an existing object)",
          "type": "string"
        },
        "ParagraphToInsert": {
          "$ref": "#/definitions/DocxParagraph",
          "description": "Table you would like to insert"
        }
      },
      "type": "object"
    },
    "InsertDocxInsertParagraphResponse": {
      "description": "Result of running an Insert-Paragraph command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "InsertDocxTableRowRequest": {
      "description": "Input to a Insert Table Row request",
      "properties": {
        "ExistingTablePath": {
          "description": "Required; the path to the existing table to modify",
          "type": "string"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "InsertPlacement": {
          "description": "Optional; default is TableEnd.  Placement Type of the insert; possible values are: TableStart (very beginning of the table), TableEnd (very end of the document), or a 0-based row index number as an integer, 0 being the first row in the table, 1 being the second row in the table, 2 being the third row in the table, etc. to insert this row after",
          "type": "string"
        },
        "RowToInsert": {
          "$ref": "#/definitions/DocxTableRow",
          "description": "Table you would like to insert"
        }
      },
      "type": "object"
    },
    "InsertDocxTableRowResponse": {
      "description": "Result of running an Insert-Table Row command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "InsertDocxTablesRequest": {
      "description": "Input to a Insert Tables request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "InsertPath": {
          "description": "Optional; location within the document to insert the object; fill in the InsertPath field using the Path value from an existing object.  Used with InsertPlacement of BeforeExistingObject or AfterExistingObject",
          "type": "string"
        },
        "InsertPlacement": {
          "description": "Optional; default is DocumentEnd.  Placement Type of the insert; possible values are: DocumentStart (very beginning of the document), DocumentEnd (very end of the document), BeforeExistingObject (right before an existing object - fill in the InsertPath field using the Path value from an existing object), AfterExistingObject (right after an existing object - fill in the InsertPath field using the Path value from an existing object)",
          "type": "string"
        },
        "TableToInsert": {
          "$ref": "#/definitions/DocxTable",
          "description": "Table you would like to insert"
        }
      },
      "type": "object"
    },
    "InsertDocxTablesResponse": {
      "description": "Result of running an Insert-Tables command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "InsertXlsxWorksheetRequest": {
      "description": "Input to a Get Worksheets request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "WorksheetToInsert": {
          "$ref": "#/definitions/XlsxWorksheet",
          "description": "Workersheet to insert"
        }
      },
      "type": "object"
    },
    "InsertXlsxWorksheetResponse": {
      "description": "Result of running a Get-Worksheets command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited XLSX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "MultipageImageFormatConversionResult": {
      "description": "Result of converting a multi-page image into individual pages with a different format",
      "properties": {
        "PageCount": {
          "description": "The number of pages in the converted output",
          "format": "int32",
          "type": "integer"
        },
        "Pages": {
          "description": "Converted page results",
          "items": {
            "$ref": "#/definitions/PageConversionResult"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "PageConversionResult": {
      "description": "Converted page as an image",
      "properties": {
        "FileBytes": {
          "description": "File bytes (contents) of the image in converted file format",
          "format": "byte",
          "type": "string"
        },
        "Filename": {
          "description": "File name of the image in the converted file format",
          "type": "string"
        }
      },
      "type": "object"
    },
    "PdfAnnotation": {
      "description": "PDF Annotation details",
      "properties": {
        "AnnotationIndex": {
          "description": "The 0-based index of the annotation in the document",
          "format": "int32",
          "type": "integer"
        },
        "AnnotationType": {
          "description": "Type of the annotation; possible values are Text",
          "type": "string"
        },
        "CreationDate": {
          "description": "Date that the annotation was created",
          "format": "date-time",
          "type": "string"
        },
        "Height": {
          "description": "Height of the annotation",
          "format": "double",
          "type": "number"
        },
        "LeftX": {
          "description": "Left X coordinate for the location of the annotation",
          "format": "double",
          "type": "number"
        },
        "ModifiedDate": {
          "description": "Date that the annotation was last modified",
          "format": "date-time",
          "type": "string"
        },
        "PageNumber": {
          "description": "The 1-based index of the page containing the annotation",
          "format": "int32",
          "type": "integer"
        },
        "Subject": {
          "description": "Subject of the annotation",
          "type": "string"
        },
        "TextContents": {
          "description": "Text contents of the annotation",
          "type": "string"
        },
        "Title": {
          "description": "Title of the annotation; this is often the author of the annotation in Acrobat-created PDF files",
          "type": "string"
        },
        "TopY": {
          "description": "Top Y coordination of the location of the annotation",
          "format": "double",
          "type": "number"
        },
        "Width": {
          "description": "Width of the annotation",
          "format": "double",
          "type": "number"
        }
      },
      "type": "object"
    },
    "PdfDocument": {
      "description": "A single PDF file corresponding to one page in the original document",
      "properties": {
        "DocumentContents": {
          "description": "If returnDocumentContents is set to true, will contain the contents of the document; otherwise will be set to null and the document contents will be available via the URL parameter",
          "format": "byte",
          "type": "string"
        },
        "PageNumber": {
          "description": "Page number of the converted page, starting with 1 for the first page",
          "format": "int32",
          "type": "integer"
        },
        "URL": {
          "description": "URL to the PDF file of this worksheet; file is stored in an in-memory cache and will be deleted",
          "type": "string"
        }
      },
      "type": "object"
    },
    "PdfFormField": {
      "description": "Field definition and value in the form",
      "properties": {
        "FieldComboBoxSelectedIndex": {
          "description": "Applies to ComboBox field types only; specifies the selected index of the combo box selection if available",
          "format": "int32",
          "type": "integer"
        },
        "FieldName": {
          "description": "Name of the form field",
          "type": "string"
        },
        "FieldType": {
          "description": "The data type of the field; possible values are Text (FieldValue will be a string), Checkbox (FieldValue can be \"true\" or \"false\"), ComboBox (FieldComboBoxSelectedIndex will also be populated), Other",
          "type": "string"
        },
        "FieldValue": {
          "description": "Value of the form field",
          "type": "string"
        }
      },
      "type": "object"
    },
    "PdfFormFields": {
      "description": "Result of retrieving PDF form fields",
      "properties": {
        "FormFields": {
          "description": "Fields and field values found in the form",
          "items": {
            "$ref": "#/definitions/PdfFormField"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "PdfMetadata": {
      "description": "Result of an autodetect/get-info operation",
      "properties": {
        "Author": {
          "description": "User name of the creator/author of the document, if available, null if not available",
          "type": "string"
        },
        "Creator": {
          "description": "Creator of the document",
          "type": "string"
        },
        "DateCreated": {
          "description": "The timestamp that the document was created, if available, null if not available",
          "format": "date-time",
          "type": "string"
        },
        "DateModified": {
          "description": "The timestamp that the document was last modified, if available, null if not available",
          "format": "date-time",
          "type": "string"
        },
        "Keywords": {
          "description": "Keywords of the document",
          "type": "string"
        },
        "PageCount": {
          "description": "The number of pages in the document",
          "format": "int32",
          "type": "integer"
        },
        "Subject": {
          "description": "Subject of the document",
          "type": "string"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        },
        "Title": {
          "description": "Title of the document",
          "type": "string"
        }
      },
      "type": "object"
    },
    "PdfPageText": {
      "description": "Text of a single page of a PDF",
      "properties": {
        "PageNumber": {
          "description": "Page number of the page (1-based)",
          "format": "int32",
          "type": "integer"
        },
        "PageText": {
          "description": "Text of the page",
          "type": "string"
        }
      },
      "type": "object"
    },
    "PdfTextByPageResult": {
      "description": "Text of the PDF, broken down by page",
      "properties": {
        "Pages": {
          "description": "Pages in the PDF",
          "items": {
            "$ref": "#/definitions/PdfPageText"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "PdfToPngResult": {
      "description": "Result of converting a PDF to a PNG array",
      "properties": {
        "PngResultPages": {
          "description": "Array of converted pages",
          "items": {
            "$ref": "#/definitions/ConvertedPngPage"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "PresentationResult": {
      "description": "A single Excel XLSX file corresponding to one worksheet (tab) in the original spreadsheet",
      "properties": {
        "PresentationContents": {
          "description": "Contents of the presentation in bytes",
          "format": "byte",
          "type": "string"
        },
        "SlideNumber": {
          "description": "Worksheet number of the converted page, starting with 1 for the left-most worksheet",
          "format": "int32",
          "type": "integer"
        },
        "URL": {
          "description": "URL to the PPTX file of this slide; file is stored in an in-memory cache and will be deleted",
          "type": "string"
        }
      },
      "type": "object"
    },
    "RemoveDocxHeadersAndFootersRequest": {
      "description": "Input to a Remove Headers and Footers request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "RemoveFooters": {
          "description": "True if you would like to remove all footers from the input document, false otherwise",
          "type": "boolean"
        },
        "RemoveHeaders": {
          "description": "True if you would like to remove all headers from the input document, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "RemoveDocxHeadersAndFootersResponse": {
      "description": "Result of running a Remove Headers and Footers command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL of the resulting edited document; this is a secure URL and cannot be downloaded without adding the Apikey header; it is also temporary, stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "RemoveDocxPagesRequest": {
      "description": "Input to a Remove Word DOCX Document Pages request",
      "properties": {
        "EndDeletePageNumber": {
          "description": "Page number (1-based) to stop deleting pages; inclusive",
          "format": "int32",
          "type": "integer"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "StartDeletePageNumber": {
          "description": "Page number (1-based) to start deleting pages; inclusive",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "RemoveHtmlFromTextRequest": {
      "description": "Request to remove HTML from a string",
      "properties": {
        "TextContainingHtml": {
          "description": "Input text string to remove the HTML from",
          "type": "string"
        }
      },
      "type": "object"
    },
    "RemoveHtmlFromTextResponse": {
      "description": "Result of removing HTML from a string",
      "properties": {
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "TextContentResult": {
          "description": "Result of performing a remove HTML from string operation",
          "type": "string"
        }
      },
      "type": "object"
    },
    "RemovePptxSlidesRequest": {
      "description": "Input to a Remove PowerPoint PPTX Presentation Slides request",
      "properties": {
        "EndDeleteSlideNumber": {
          "description": "Slide number (1-based) to stop deleting slides; inclusive",
          "format": "int32",
          "type": "integer"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "StartDeleteSlideNumber": {
          "description": "Slide number (1-based) to start deleting slides; inclusive",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "RemoveWhitespaceFromTextRequest": {
      "description": "Request to remove whitespace from a string",
      "properties": {
        "TextContainingWhitespace": {
          "description": "Input text string to remove the whitespace from",
          "type": "string"
        }
      },
      "type": "object"
    },
    "RemoveWhitespaceFromTextResponse": {
      "description": "Result of removing whitespace from a string",
      "properties": {
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "TextContentResult": {
          "description": "Result of performing a remove whitespace from string operation",
          "type": "string"
        }
      },
      "type": "object"
    },
    "RemoveXlsxWorksheetRequest": {
      "description": "Input to a Remove Excel XLSX Spreadsheet worksheet request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "WorksheetToRemove": {
          "$ref": "#/definitions/XlsxWorksheet",
          "description": "Required; Worksheet (tab) within the spreadsheet to delete; leave blank to default to the first worksheet.  Use the Get Worksheets API to enumerate available worksheets in a spreadsheet."
        }
      },
      "type": "object"
    },
    "ReplaceStringRegexRequest": {
      "description": "Request to replace a regex string in a string",
      "properties": {
        "RegularExpressionString": {
          "description": "Target input regular expression (regex) string to match and be replaced; supports all regular expression values",
          "type": "string"
        },
        "ReplaceWithString": {
          "description": "Replacement for target string; supports referencing indexed regex matched values from RegularExpressionString, such as $1, $2, and so on",
          "type": "string"
        },
        "TextContent": {
          "description": "Input text content",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ReplaceStringRegexResponse": {
      "description": "Result of replacing a regex string",
      "properties": {
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "TextContentResult": {
          "description": "Result of performing a base 64 decode operation, binary file content",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ReplaceStringRequest": {
      "description": "Input to a string replacement request",
      "properties": {
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "MatchCase": {
          "description": "True if the case should be matched, false for case insensitive match",
          "type": "boolean"
        },
        "MatchString": {
          "description": "String to search for and match against, to be replaced",
          "type": "string"
        },
        "ReplaceString": {
          "description": "String to replace the matched values with",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ReplaceStringSimpleRequest": {
      "description": "Request to replace a string in a string",
      "properties": {
        "ReplaceWithString": {
          "description": "Replacement for target string",
          "type": "string"
        },
        "TargetString": {
          "description": "Target input string to match and be replaced",
          "type": "string"
        },
        "TextContent": {
          "description": "Input text content",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ReplaceStringSimpleResponse": {
      "description": "Result of replacing a string",
      "properties": {
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "TextContentResult": {
          "description": "Result of performing a replace string operation",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ScreenshotRequest": {
      "description": "Details of the screenshot request",
      "properties": {
        "ExtraLoadingWait": {
          "description": "Optional: Additional number of milliseconds to wait once the web page has finished loading before taking the screenshot.  Can be helpful for highly asynchronous websites.  Provide a value of 0 for the default of 5000 milliseconds (5 seconds)",
          "format": "int32",
          "type": "integer"
        },
        "ScreenshotHeight": {
          "description": "Optional: Height of the screenshot in pixels; supply 0 to default to 1280 x 1024, supply -1 to measure the full screen height of the page and attempt to take a screen-height screenshot",
          "format": "int32",
          "type": "integer"
        },
        "ScreenshotWidth": {
          "description": "Optional: Width of the screenshot in pixels; supply 0 to default to 1280 x 1024",
          "format": "int32",
          "type": "integer"
        },
        "Url": {
          "description": "URL address of the website to screenshot.  HTTP and HTTPS are both supported, as are custom ports.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SetFormFieldValue": {
      "description": "Individual field value to set in a PDF form",
      "properties": {
        "CheckboxValue": {
          "description": "For fields of type Checkbox, the value to put into the field",
          "type": "boolean"
        },
        "ComboBoxSelectedIndex": {
          "description": "For fields of type ComboBox; specifies the selected index of the combo box selection",
          "format": "int32",
          "type": "integer"
        },
        "FieldName": {
          "description": "Name of the field to set; you can call /convert/edit/pdf/form/get-fields to enumerate field names in a form",
          "type": "string"
        },
        "TextValue": {
          "description": "For fields of type Text, the text value to put into the field",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SetPdfFormFieldsRequest": {
      "description": "Request to set the fields in a PDF form",
      "properties": {
        "FieldValues": {
          "description": "Field values to set",
          "items": {
            "$ref": "#/definitions/SetFormFieldValue"
          },
          "type": "array"
        },
        "InputFileBytes": {
          "description": "Contents of the input file to set the fields on",
          "format": "byte",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SetPdfMetadataRequest": {
      "description": "Request to set PDF metadata",
      "properties": {
        "InputFileBytes": {
          "description": "Input file contents bytes for the file to modify",
          "format": "byte",
          "type": "string"
        },
        "MetadataToSet": {
          "$ref": "#/definitions/PdfMetadata",
          "description": "PDF metadata to set on the file"
        }
      },
      "type": "object"
    },
    "SetXlsxCellByIdentifierRequest": {
      "description": "Input to a Set Cell by identifier in XLSX Worksheets request",
      "properties": {
        "CellIdentifier": {
          "description": "The Excel cell identifier (e.g. A1, B2, C33, etc.) of the cell to update",
          "type": "string"
        },
        "CellValue": {
          "$ref": "#/definitions/XlsxSpreadsheetCell",
          "description": "New Cell value to update/overwrite into the Excel XLSX spreadsheet"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "WorksheetToUpdate": {
          "$ref": "#/definitions/XlsxWorksheet",
          "description": "Optional; Worksheet (tab) within the spreadsheet to update; leave blank to default to the first worksheet"
        }
      },
      "type": "object"
    },
    "SetXlsxCellByIdentifierResponse": {
      "description": "Result of running a Set Cell by identifier in XLSX Worksheets command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited XLSX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SetXlsxCellRequest": {
      "description": "Input to a Set Cell in XLSX Worksheets request",
      "properties": {
        "CellIndex": {
          "description": "0-based index of the cell, 0, 1, 2, ... in the row to set",
          "format": "int32",
          "type": "integer"
        },
        "CellValue": {
          "$ref": "#/definitions/XlsxSpreadsheetCell",
          "description": "New Cell value to update/overwrite into the Excel XLSX spreadsheet"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "RowIndex": {
          "description": "0-based index of the row, 0, 1, 2, ... to set",
          "format": "int32",
          "type": "integer"
        },
        "WorksheetToUpdate": {
          "$ref": "#/definitions/XlsxWorksheet",
          "description": "Optional; Worksheet (tab) within the spreadsheet to update; leave blank to default to the first worksheet"
        }
      },
      "type": "object"
    },
    "SetXlsxCellResponse": {
      "description": "Result of running a Set Cell in XLSX Worksheets command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited XLSX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SplitDocumentResult": {
      "description": "A single Word DOCX file corresponding to one page in the original document",
      "properties": {
        "DocumentContents": {
          "description": "Contents of the document in bytes",
          "format": "byte",
          "type": "string"
        },
        "PageNumber": {
          "description": "Page number of the converted page, starting with 1 for the first page",
          "format": "int32",
          "type": "integer"
        },
        "URL": {
          "description": "URL to the DOCX file of this slide; file is stored in an in-memory cache and will be deleted",
          "type": "string"
        }
      },
      "type": "object"
    },
    "SplitDocxDocumentResult": {
      "description": "The result of splitting a Word document into individual Word DOCX pages",
      "properties": {
        "ResultDocuments": {
          "items": {
            "$ref": "#/definitions/SplitDocumentResult"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SplitPdfResult": {
      "description": "Result of performing a PDF file split operation",
      "properties": {
        "Documents": {
          "description": "PDF documents as output",
          "items": {
            "$ref": "#/definitions/PdfDocument"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SplitPptxPresentationResult": {
      "description": "The result of splitting a presentation into individual PowerPoint PPTX slides",
      "properties": {
        "ResultPresentations": {
          "items": {
            "$ref": "#/definitions/PresentationResult"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SplitTextDocumentByLinesResult": {
      "description": "The result of splitting a Text document into separate lines",
      "properties": {
        "LineCount": {
          "description": "The count of lines in the text file",
          "format": "int32",
          "type": "integer"
        },
        "ResultLines": {
          "items": {
            "$ref": "#/definitions/TextDocumentLine"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SplitTextDocumentByStringResult": {
      "description": "The result of splitting a Text document into separate elements",
      "properties": {
        "ElementCount": {
          "description": "The count of elements in the text file",
          "format": "int32",
          "type": "integer"
        },
        "ResultElements": {
          "items": {
            "$ref": "#/definitions/TextDocumentElement"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SplitXlsxWorksheetResult": {
      "description": "The result of splitting a spreadsheet into individual Excel XLSX worksheets",
      "properties": {
        "ResultWorksheets": {
          "items": {
            "$ref": "#/definitions/WorksheetResult"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TextConversionResult": {
      "description": "Text conversion result from converting a document to Plain Text (TXT) format",
      "properties": {
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        },
        "TextResult": {
          "description": "Plain Text (TXT) format conversion result of the input document.  The text result is returned as a string.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "TextDocumentElement": {
      "description": "A single element of a Text document",
      "properties": {
        "ElementContents": {
          "description": "The text contents of a single element of a text file",
          "type": "string"
        },
        "ElementNumber": {
          "description": "The 1-based line index of the element",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TextDocumentLine": {
      "description": "A single line of a Text document",
      "properties": {
        "LineContents": {
          "description": "The text contents of a single line of a text file",
          "type": "string"
        },
        "LineNumber": {
          "description": "The 1-based line index of the line",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "TextEncodingDetectResponse": {
      "description": "Result of detecting text encoding",
      "properties": {
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "TextEncoding": {
          "description": "Text encoding used in file; possible values are ASCII, UTF7, UTF8, UTF16, BigEndianUnicode and UTF32",
          "type": "string"
        }
      },
      "type": "object"
    },
    "UpdateDocxTableCellRequest": {
      "description": "Input to a Update Table Cell request",
      "properties": {
        "CellToUpdate": {
          "$ref": "#/definitions/DocxTableCell",
          "description": "Table cell contents you would like to update the cell with"
        },
        "ExistingTablePath": {
          "description": "Required; the path to the existing table to modify",
          "type": "string"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "TableCellIndex": {
          "description": "0-based index of the Table Cell (within the row) to update",
          "format": "int32",
          "type": "integer"
        },
        "TableRowIndex": {
          "description": "0-based index of the Table Row to update",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "UpdateDocxTableCellResponse": {
      "description": "Result of running an Update Table Cell command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "UpdateDocxTableRowRequest": {
      "description": "Input to a Update Table Row request",
      "properties": {
        "ExistingTablePath": {
          "description": "Required; the path to the existing table to modify",
          "type": "string"
        },
        "InputFileBytes": {
          "description": "Optional: Bytes of the input file to operate on",
          "format": "byte",
          "type": "string"
        },
        "InputFileUrl": {
          "description": "Optional: URL of a file to operate on as input.  This can be a public URL, or you can also use the begin-editing API to upload a document and pass in the secure URL result from that operation as the URL here (this URL is not public).",
          "type": "string"
        },
        "RowToUpdate": {
          "$ref": "#/definitions/DocxTableRow",
          "description": "Table row contents you would like to update the row with"
        },
        "TableRowIndex": {
          "description": "0-based index of the Table Row to update",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "UpdateDocxTableRowResponse": {
      "description": "Result of running an Update Table Row command",
      "properties": {
        "EditedDocumentURL": {
          "description": "URL to the edited DOCX file; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the result document contents.",
          "type": "string"
        },
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "UrlToPdfRequest": {
      "description": "Request to convert a URL to a PDF file",
      "properties": {
        "ExtraLoadingWait": {
          "description": "Optional: Additional number of milliseconds to wait once the web page has finished loading before taking the screenshot.  Can be helpful for highly asynchronous websites.  Provide a value of 0 for the default of 5000 milliseconds (5 seconds)",
          "format": "int32",
          "type": "integer"
        },
        "IncludeBackgroundGraphics": {
          "description": "Optional: Set to true to include background graphics in the PDF, or false to not include.  Default is true.",
          "type": "boolean"
        },
        "Url": {
          "description": "URL address of the website to screenshot.  HTTP and HTTPS are both supported, as are custom ports.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "UrlToTextRequest": {
      "description": "Details of the URL website to Text request",
      "properties": {
        "Url": {
          "description": "URL of the website to extract the text from",
          "type": "string"
        }
      },
      "type": "object"
    },
    "UrlToTextResponse": {
      "description": "Result of running the URL website to Text operation",
      "properties": {
        "Successful": {
          "description": "True if successful, false otherwise",
          "type": "boolean"
        },
        "TextContentResult": {
          "description": "Text content result from the URL website input",
          "type": "string"
        }
      },
      "type": "object"
    },
    "ViewerResponse": {
      "description": "Result of creating a viewer",
      "properties": {
        "HtmlEmbed": {
          "type": "string"
        },
        "Successful": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "WorksheetResult": {
      "description": "A single Excel XLSX file corresponding to one worksheet (tab) in the original spreadsheet",
      "properties": {
        "URL": {
          "description": "URL to the XLSX file of this worksheet; file is stored in an in-memory cache and will be deleted",
          "type": "string"
        },
        "WorksheetContents": {
          "description": "Contents of the worksheet in bytes",
          "format": "byte",
          "type": "string"
        },
        "WorksheetName": {
          "description": "The name of the worksheet",
          "type": "string"
        },
        "WorksheetNumber": {
          "description": "Worksheet number of the converted page, starting with 1 for the left-most worksheet",
          "format": "int32",
          "type": "integer"
        }
      },
      "type": "object"
    },
    "XlsxImage": {
      "properties": {
        "ImageContentsURL": {
          "description": "URL to the image contents; file is stored in an in-memory cache and will be deleted.  Call Finish-Editing to get the contents.",
          "type": "string"
        },
        "ImageDataContentType": {
          "description": "Read-only; image data MIME content-type",
          "type": "string"
        },
        "ImageDataEmbedId": {
          "description": "Read-only; internal ID for the image contents",
          "type": "string"
        },
        "ImageInternalFileName": {
          "description": "Read-only; internal file name/path for the image",
          "type": "string"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new rows",
          "type": "string"
        }
      },
      "type": "object"
    },
    "XlsxSpreadsheetCell": {
      "description": "Cell in an Excel Spreadsheet worksheet",
      "properties": {
        "CellIdentifier": {
          "description": "Cell reference of the cell, e.g. A1, Z22, etc.",
          "type": "string"
        },
        "Formula": {
          "type": "string"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new rows",
          "type": "string"
        },
        "StyleIndex": {
          "description": "Identifier for the style to apply to this style",
          "format": "int32",
          "type": "integer"
        },
        "TextValue": {
          "description": "Text value of the cell",
          "type": "string"
        }
      },
      "type": "object"
    },
    "XlsxSpreadsheetColumn": {
      "description": "Column in an Excel spreadsheet worksheet",
      "properties": {
        "HeadingCell": {
          "$ref": "#/definitions/XlsxSpreadsheetCell",
          "description": "Heading cell for this column"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new rows",
          "type": "string"
        }
      },
      "type": "object"
    },
    "XlsxSpreadsheetRow": {
      "description": "Row in an Excel spreadsheet worksheet",
      "properties": {
        "Cells": {
          "description": "Spreadsheet Cells in the spreadsheet row",
          "items": {
            "$ref": "#/definitions/XlsxSpreadsheetCell"
          },
          "type": "array"
        },
        "Path": {
          "description": "The Path of the location of this object; leave blank for new rows",
          "type": "string"
        }
      },
      "type": "object"
    },
    "XlsxWorksheet": {
      "description": "A worksheet (tab) in an Excel (XLSX) spreadsheet",
      "properties": {
        "Path": {
          "description": "The Path of the location of this object; leave blank for new worksheets",
          "type": "string"
        },
        "WorksheetName": {
          "description": "User-facing name of the worksheet tab",
          "type": "string"
        }
      },
      "type": "object"
    },
    "XmlAddAttributeWithXPathResult": {
      "description": "Result of performing a add attribute node operation on XML input using XPath",
      "properties": {
        "NodesEditedCount": {
          "description": "Count of the matching results",
          "format": "int32",
          "type": "integer"
        },
        "ResultingXmlDocument": {
          "description": "Resulting, modified XML document",
          "type": "string"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "XmlAddChildWithXPathResult": {
      "description": "Result of performing a add child node operation on XML input using XPath",
      "properties": {
        "NodesEditedCount": {
          "description": "Count of the matching results",
          "format": "int32",
          "type": "integer"
        },
        "ResultingXmlDocument": {
          "description": "Resulting, modified XML document",
          "type": "string"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "XmlFilterWithXPathResult": {
      "description": "Result of performing a filter operation on XML input using XPath",
      "properties": {
        "ResultCount": {
          "description": "Count of the matching results",
          "format": "int32",
          "type": "integer"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        },
        "XmlNodes": {
          "description": "Matching selected XML nodes as strings",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "XmlQueryWithXQueryMultiResult": {
      "description": "Result of performing an XQuery operation on multiple XML documents.",
      "properties": {
        "ErrorMessage": {
          "description": "If an error occurs, additional details on the error",
          "type": "string"
        },
        "ResultingXml": {
          "description": "Resulting XML result output",
          "type": "string"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "XmlQueryWithXQueryResult": {
      "description": "Result of performing an XQuery operation on an XML document.",
      "properties": {
        "ErrorMessage": {
          "description": "If an error occurs, additional details on the error",
          "type": "string"
        },
        "ResultingXml": {
          "description": "Resulting XML result output",
          "type": "string"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "XmlRemoveAllChildrenWithXPathResult": {
      "description": "Result of performing a remove all child nodes operation on XML input using XPath",
      "properties": {
        "NodesEditedCount": {
          "description": "Count of the matching results",
          "format": "int32",
          "type": "integer"
        },
        "ResultingXmlDocument": {
          "description": "Resulting, modified XML document",
          "type": "string"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "XmlRemoveWithXPathResult": {
      "description": "Result of performing a filter operation on XML input using XPath",
      "properties": {
        "NodesRemovedCount": {
          "description": "Count of the matching results",
          "format": "int32",
          "type": "integer"
        },
        "ResultingXmlDocument": {
          "description": "Resulting, modified XML document with matching nodes removed as a string",
          "type": "string"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        },
        "XmlNodesRemoved": {
          "description": "Matching selected XML nodes as strings",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "XmlReplaceWithXPathResult": {
      "description": "Result of performing a replace node operation on XML input using XPath",
      "properties": {
        "NodesEditedCount": {
          "description": "Count of the matching results",
          "format": "int32",
          "type": "integer"
        },
        "ResultingXmlDocument": {
          "description": "Resulting, modified XML document",
          "type": "string"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "XmlSetValueWithXPathResult": {
      "description": "Result of performing a set value operation on XML input using XPath",
      "properties": {
        "NodesEditedCount": {
          "description": "Count of the matching results",
          "format": "int32",
          "type": "integer"
        },
        "ResultingXmlDocument": {
          "description": "Resulting, modified XML document",
          "type": "string"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ZipDirectory": {
      "description": "Representation of a directory in a zip file",
      "properties": {
        "DirectoriesInDirectory": {
          "description": "Child directories contained directly in this directory",
          "items": {
            "$ref": "#/definitions/ZipDirectory"
          },
          "type": "array"
        },
        "DirectoryName": {
          "description": "Name of this directory",
          "type": "string"
        },
        "FilesInDirectory": {
          "description": "Child files contained directly in this directory",
          "items": {
            "$ref": "#/definitions/ZipFile"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "ZipExtractResponse": {
      "description": "Result of performing a zip extract operation",
      "properties": {
        "DirectoriesInZip": {
          "description": "Top-level directories in the root directory of the zip; directories can contain sub-directories and files",
          "items": {
            "$ref": "#/definitions/ZipDirectory"
          },
          "type": "array"
        },
        "FilesInZip": {
          "description": "Top-level files in the root directory fo the zip file",
          "items": {
            "$ref": "#/definitions/ZipFile"
          },
          "type": "array"
        },
        "Successful": {
          "description": "True if the operation was successful, false otherwise",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ZipFile": {
      "description": "Representation of a file in a zip file",
      "properties": {
        "FileContents": {
          "description": "Contents of this file",
          "format": "byte",
          "type": "string"
        },
        "FileName": {
          "description": "Name of this file",
          "type": "string"
        }
      },
      "type": "object"
    }
  },
  "host": "api.cloudmersive.com",
  "info": {
    "description": "PDF lets you effortlessly create, convert, process, edit, work with, encrypt, and sign PDF files.",
    "title": "Cloudmersive PDF",
    "version": "v1",
    "x-ms-api-annotation": {
      "status": "Preview"
    }
  },
  "paths": {
    "/convert/edit/pdf/annotations/add-item": {
      "post": {
        "consumes": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml",
          "application/x-www-form-urlencoded"
        ],
        "description": "Adds one or more annotations, comments to a PDF document.",
        "operationId": "EditPdf_AddAnnotations",
        "parameters": [
          {
            "in": "body",
            "name": "request",
            "required": true,
            "schema": {
              "$ref": "#/definitions/AddPdfAnnotationRequest"
            },
            "x-ms-summary": ""
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Add one or more PDF annotations, comments in the PDF document",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/annotations/list": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Enumerates the annotations, including comments and notes, in a PDF document.",
        "operationId": "EditPdf_GetAnnotations",
        "parameters": [
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/GetPdfAnnotationsResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Get PDF annotations, including comments in the document",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/annotations/remove-all": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Removes all of the annotations, including comments and notes, in a PDF document.",
        "operationId": "EditPdf_RemoveAllAnnotations",
        "parameters": [
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Remove all PDF annotations, including comments in the document",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/annotations/remove-item": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Removes a specific annotation in a PDF document, using the AnnotationIndex.  To enumerate AnnotationIndex for all of the annotations in the PDF document, use the /edit/pdf/annotations/list API.",
        "operationId": "EditPdf_RemoveAnnotationItem",
        "parameters": [
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          },
          {
            "description": "The 0-based index of the annotation in the document",
            "in": "header",
            "name": "annotationIndex",
            "required": true,
            "type": "integer",
            "x-ms-summary": "The 0-based index of the annotation in the document"
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Remove a specific PDF annotation, comment in the document",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/decrypt": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Decrypt a PDF document with a password.  Decrypted PDF will no longer require a password to open.",
        "operationId": "EditPdf_Decrypt",
        "parameters": [
          {
            "description": "Valid password for the PDF file",
            "in": "header",
            "name": "password",
            "required": true,
            "type": "string",
            "x-ms-summary": "Valid password for the PDF file"
          },
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Decrypt and password-protect a PDF",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/encrypt": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Encrypt a PDF document with a password.  Set an owner password to control owner (editor/creator) permissions, and set a user (reader) password to control the viewer of the PDF.  Set the password fields null to omit the given password.",
        "operationId": "EditPdf_Encrypt",
        "parameters": [
          {
            "description": "Password of a user (reader) of the PDF file",
            "in": "header",
            "name": "userPassword",
            "required": false,
            "type": "string",
            "x-ms-summary": "Password of a user (reader) of the PDF file"
          },
          {
            "description": "Password of a owner (creator/editor) of the PDF file",
            "in": "header",
            "name": "ownerPassword",
            "required": false,
            "type": "string",
            "x-ms-summary": "Password of a owner (creator/editor) of the PDF file"
          },
          {
            "description": "Possible values are \"128\" (128-bit RC4 encryption) and \"256\" (256-bit",
            "in": "header",
            "name": "encryptionKeyLength",
            "required": false,
            "type": "string",
            "x-ms-summary": "Possible values are \"128\" (128-bit RC4 encryption) and \"256\" (256-bit"
          },
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Encrypt and password-protect a PDF",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/encrypt/set-permissions": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Encrypt a PDF document with a password, and set permissions on the PDF.  Set an owner password to control owner (editor/creator) permissions [required], and set a user (reader) password to control the viewer of the PDF [optional].  Set the reader password to null to omit the password.  Restrict or allow printing, copying content, document assembly, editing (read-only), form filling, modification of annotations, and degraded printing through document Digital Rights Management (DRM).",
        "operationId": "EditPdf_SetPermissions",
        "parameters": [
          {
            "description": "Password of a owner (creator/editor) of the PDF file (required)",
            "in": "header",
            "name": "ownerPassword",
            "required": true,
            "type": "string",
            "x-ms-summary": "Password of a owner (creator/editor) of the PDF file (required)"
          },
          {
            "description": "Password of a user (reader) of the PDF file (optional)",
            "in": "header",
            "name": "userPassword",
            "required": true,
            "type": "string",
            "x-ms-summary": "Password of a user (reader) of the PDF file (optional)"
          },
          {
            "description": "Possible values are \"128\" (128-bit RC4 encryption) and \"256\" (256-bit",
            "in": "header",
            "name": "encryptionKeyLength",
            "required": false,
            "type": "string",
            "x-ms-summary": "Possible values are \"128\" (128-bit RC4 encryption) and \"256\" (256-bit"
          },
          {
            "description": "Set to false to disable printing through DRM.  Default is true.",
            "in": "header",
            "name": "allowPrinting",
            "required": false,
            "type": "boolean",
            "x-ms-summary": "Set to false to disable printing through DRM.  Default is true."
          },
          {
            "description": "Set to false to disable document assembly through DRM.  Default is true.",
            "in": "header",
            "name": "allowDocumentAssembly",
            "required": false,
            "type": "boolean",
            "x-ms-summary": "Set to false to disable document assembly through DRM.  Default is true."
          },
          {
            "description": "Set to false to disable copying/extracting content out of the PDF thro",
            "in": "header",
            "name": "allowContentExtraction",
            "required": false,
            "type": "boolean",
            "x-ms-summary": "Set to false to disable copying/extracting content out of the PDF thro"
          },
          {
            "description": "Set to false to disable filling out form fields in the PDF through DRM",
            "in": "header",
            "name": "allowFormFilling",
            "required": false,
            "type": "boolean",
            "x-ms-summary": "Set to false to disable filling out form fields in the PDF through DRM"
          },
          {
            "description": "Set to false to disable editing in the PDF through DRM (making the PDF",
            "in": "header",
            "name": "allowEditing",
            "required": false,
            "type": "boolean",
            "x-ms-summary": "Set to false to disable editing in the PDF through DRM (making the PDF"
          },
          {
            "description": "Set to false to disable annotations and editing of annotations in the",
            "in": "header",
            "name": "allowAnnotations",
            "required": false,
            "type": "boolean",
            "x-ms-summary": "Set to false to disable annotations and editing of annotations in the"
          },
          {
            "description": "Set to false to disable degraded printing of the PDF through DRM.  Def",
            "in": "header",
            "name": "allowDegradedPrinting",
            "required": false,
            "type": "boolean",
            "x-ms-summary": "Set to false to disable degraded printing of the PDF through DRM.  Def"
          },
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Encrypt, password-protect and set restricted permissions on a PDF",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/form/get-fields": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Encrypt a PDF document with a password.  Set an owner password to control owner (editor/creator) permissions, and set a user (reader) password to control the viewer of the PDF.  Set the password fields null to omit the given password.",
        "operationId": "EditPdf_GetFormFields",
        "parameters": [
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PdfFormFields"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Gets PDF Form fields and values",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/form/set-fields": {
      "post": {
        "consumes": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml",
          "application/x-www-form-urlencoded"
        ],
        "description": "Fill in the form fields in a PDF form with specific values.  Use form/get-fields to enumerate the available fields and their data types in an input form.",
        "operationId": "EditPdf_SetFormFields",
        "parameters": [
          {
            "in": "body",
            "name": "fieldValues",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SetPdfFormFieldsRequest"
            },
            "x-ms-summary": ""
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Sets ands fills PDF Form field values",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/get-metadata": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Returns the metadata from the PDF document, including Title, Author, etc.",
        "operationId": "EditPdf_GetMetadata",
        "parameters": [
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PdfMetadata"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Get PDF document metadata",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/pages/delete": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Remove one or more pages from a PDF document",
        "operationId": "EditPdf_DeletePages",
        "parameters": [
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          },
          {
            "description": "Page number (1 based) to start deleting pages from (inclusive).",
            "in": "header",
            "name": "pageStart",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Page number (1 based) to start deleting pages from (inclusive)."
          },
          {
            "description": "Page number (1 based) to stop deleting pages from (inclusive).",
            "in": "header",
            "name": "pageEnd",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Page number (1 based) to stop deleting pages from (inclusive)."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Remove, delete pages from a PDF document",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/pages/get-text": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Gets the text in a PDF by page",
        "operationId": "EditPdf_GetPdfTextByPages",
        "parameters": [
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          }
        ],
        "produces": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/PdfTextByPageResult"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Get text in a PDF document by page",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/pages/insert": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Copy one or more pages from one PDF document (source document) and insert them into a second PDF document (destination document).",
        "operationId": "EditPdf_InsertPages",
        "parameters": [
          {
            "description": "Source PDF file to copy pages from.",
            "in": "formData",
            "name": "sourceFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Source PDF file to copy pages from."
          },
          {
            "description": "Destination PDF file to copy pages into.",
            "in": "formData",
            "name": "destinationFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Destination PDF file to copy pages into."
          },
          {
            "description": "Page number (1 based) to start copying pages from (inclusive) in the S",
            "in": "header",
            "name": "pageStartSource",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Page number (1 based) to start copying pages from (inclusive) in the S"
          },
          {
            "description": "Page number (1 based) to stop copying pages pages from (inclusive) in",
            "in": "header",
            "name": "pageEndSource",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Page number (1 based) to stop copying pages pages from (inclusive) in"
          },
          {
            "description": "Page number (1 based) to insert the pages before in the Destination file.",
            "in": "header",
            "name": "pageInsertBeforeDesitnation",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Page number (1 based) to insert the pages before in the Destination file."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Insert, copy pages from one PDF document into another",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/pages/rotate/all": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Rotate all of the pages in a PDF document by a multiple of 90 degrees",
        "operationId": "EditPdf_RotateAllPages",
        "parameters": [
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          },
          {
            "description": "The angle to rotate the page in degrees, must be a multiple of 90 degr",
            "in": "header",
            "name": "rotationAngle",
            "required": true,
            "type": "integer",
            "x-ms-summary": "The angle to rotate the page in degrees, must be a multiple of 90 degr"
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Rotate all pages in a PDF document",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/pages/rotate/page-range": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Rotate a range of specific pages in a PDF document by a multiple of 90 degrees",
        "operationId": "EditPdf_RotatePageRange",
        "parameters": [
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          },
          {
            "description": "The angle to rotate the page in degrees, must be a multiple of 90 degr",
            "in": "header",
            "name": "rotationAngle",
            "required": true,
            "type": "integer",
            "x-ms-summary": "The angle to rotate the page in degrees, must be a multiple of 90 degr"
          },
          {
            "description": "Page number (1 based) to start rotating pages from (inclusive).",
            "in": "header",
            "name": "pageStart",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Page number (1 based) to start rotating pages from (inclusive)."
          },
          {
            "description": "Page number (1 based) to stop rotating pages from (inclusive).",
            "in": "header",
            "name": "pageEnd",
            "required": true,
            "type": "integer",
            "x-ms-summary": "Page number (1 based) to stop rotating pages from (inclusive)."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Rotate a range, subset of pages in a PDF document",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/rasterize": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Rasterize a PDF into an image-based PDF.  The output is a PDF where each page is comprised of a high-resolution image, with all text, figures and other components removed.",
        "operationId": "EditPdf_Rasterize",
        "parameters": [
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Rasterize a PDF to an image-based PDF",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/set-metadata": {
      "post": {
        "consumes": [
          "application/json",
          "text/json",
          "application/xml",
          "text/xml",
          "application/x-www-form-urlencoded"
        ],
        "description": "Sets (writes) metadata into the input PDF document, including Title, Author, etc.",
        "operationId": "EditPdf_SetMetadata",
        "parameters": [
          {
            "in": "body",
            "name": "request",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SetPdfMetadataRequest"
            },
            "x-ms-summary": ""
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Sets PDF document metadata",
        "tags": [
          "EditPdf"
        ]
      }
    },
    "/convert/edit/pdf/watermark/text": {
      "post": {
        "consumes": [
          "multipart/form-data"
        ],
        "description": "Adds a text watermark to a PDF",
        "operationId": "EditPdf_WatermarkText",
        "parameters": [
          {
            "description": "Watermark text to add to the PDF (required)",
            "in": "header",
            "name": "watermarkText",
            "required": true,
            "type": "string",
            "x-ms-summary": "Watermark text to add to the PDF (required)"
          },
          {
            "description": "Font Family Name for the watermark text; default is Times New Roman",
            "in": "header",
            "name": "fontName",
            "required": false,
            "type": "string",
            "x-ms-summary": "Font Family Name for the watermark text; default is Times New Roman"
          },
          {
            "description": "Font Size in points of the text; default is 150",
            "in": "header",
            "name": "fontSize",
            "required": false,
            "type": "number",
            "x-ms-summary": "Font Size in points of the text; default is 150"
          },
          {
            "description": "Font color in hexadecimal or HTML color name; default is Red",
            "in": "header",
            "name": "fontColor",
            "required": false,
            "type": "string",
            "x-ms-summary": "Font color in hexadecimal or HTML color name; default is Red"
          },
          {
            "description": "Font transparency between 0.0 (completely transparent) to 1.0 (fully o",
            "in": "header",
            "name": "fontTransparency",
            "required": false,
            "type": "number",
            "x-ms-summary": "Font transparency between 0.0 (completely transparent) to 1.0 (fully o"
          },
          {
            "description": "Input file to perform the operation on.",
            "in": "formData",
            "name": "inputFile",
            "required": true,
            "type": "file",
            "x-ms-summary": "Input file to perform the operation on."
          }
        ],
        "produces": [
          "application/octet-stream"
        ],
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "description": "Output file content from the operation",
              "format": "binary",
              "title": "OutputContent",
              "type": "string"
            }
          }
        },
        "security": [
          {
            "Apikey": []
          }
        ],
        "summary": "Add a text watermark to a PDF",
        "tags": [
          "EditPdf"
        ]
      }
    }
  },
  "schemes": [
    "https"
  ],
  "securityDefinitions": {
    "Apikey": {
      "description": "API Key Authentication",
      "in": "header",
      "name": "Apikey",
      "type": "apiKey"
    }
  },
  "swagger": "2.0"
}