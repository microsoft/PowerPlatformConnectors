{
  "basePath": "/v1/",
  "consumes": [
    "application/json"
  ],
  "definitions": {
    "Address": {
      "properties": {
        "administrative_county": {
          "description": "The current administrative county to which the postcode has been assigned. A Unitary Authority name, where one is present. If there is no Unitary Authority, the County name is used. This information is not static, because County boundaries may change due to administrative changes. Data source: ONS. May be empty.",
          "type": "string"
        },
        "building_name": {
          "description": "Name of residential or commercial premise. E.g. The Manor, 1-2, A, 12A, K, Victoria House",
          "maxLength": 50,
          "type": "string"
        },
        "building_number": {
          "description": "Number to identify premise on a thoroughfare or dependant thoroughfare.",
          "maxLength": 4,
          "type": "string"
        },
        "country": {
          "description": "The country for which the postcode belongs to. May be empty for a small number of addresses. Data source: ONS",
          "type": "string"
        },
        "county": {
          "description": "Since postal, administrative or traditional counties may not apply to some addresses, the county field is designed to return whatever county data is available. Normally, the postal county is returned. If this is not present, the county field will fall back to the administrative county. If the administrative county is also not present, the county field will fall back to the traditional county. May be empty in cases where no administrative, postal or traditional county present.",
          "type": "string"
        },
        "delivery_point_suffix": {
          "description": "A unique Royal Mail 2-character code (the first numeric & the second alphabetical), which, when added to the Postcode, enables each live Delivery Point to be uniquely identified. Once the Delivery Point is deleted from PAF the DPS may be reused (although they aren\u2019t reused until all remaining Delivery Points in the range have been allocated). The DPS for a Large User is always '1A' as each Large User has its own Postcode. E.g. 2B",
          "type": "string"
        },
        "department_name": {
          "description": "Used to supplment Organisation Name to identify a deparment within the organisation.",
          "maxLength": 60,
          "type": "string"
        },
        "dependent_locality": {
          "description": "When the same thoroughfare name reoccurs in a Post town, it may not be possible to make it dependant on a dependant thoroughfare. In this case the thoroughfare is dependant on a locality. For example if we want to find 1 Back Lane in Huddersfield we see that there are three.",
          "maxLength": 35,
          "type": "string"
        },
        "dependent_thoroughfare": {
          "description": "Used to supplement thoroughfare. When a thoroughfare name is used twice in the same Post Town, the dependant thoroughfare is added to uniquely indentify a delivery point.",
          "maxLength": 80,
          "type": "string"
        },
        "district": {
          "description": "The current district/unitary authority to which the postcode has been assigned. Data source: ONS",
          "type": "string"
        },
        "double_dependent_locality": {
          "description": "Used to supplement Dependant Locality. A Double Dependant Locality supplied along with a Dependant Locality if the Dependant Locality exists twice in the same locality.",
          "maxLength": 35,
          "type": "string"
        },
        "eastings": {
          "description": "Eastings reference using the Ordnance Survey National Grid reference system. Northern Ireland Eastings uses the Irish Grid Reference System. Metres from origin. E.g. 550458. Returns an empty string if no location data is available. Otherwise a number is returned",
          "format": "int32",
          "type": "integer"
        },
        "latitude": {
          "description": "The latitude of the postcode (WGS84/ETRS89). Accurate at the postcode level Can be a positive or negative decimal. E.g. 51.5083983. Returns an empty string if no location data is available. Otherwise a number is returned",
          "format": "double",
          "type": "number"
        },
        "line_1": {
          "description": "First Address Line. Often contains premise and thoroughfare information. In the case of a commercial premise, the first line is always the full name of the registered organisation. Never empty.",
          "type": "string"
        },
        "line_2": {
          "description": "Second Address Line. Often contains thoroughfare and locality information. May be empty.",
          "type": "string"
        },
        "line_3": {
          "description": "Third address line. May be empty.",
          "type": "string"
        },
        "longitude": {
          "description": "The longitude of the postcode (WGS84/ETRS89). Accurate at the postcode level. Can be a positive or negative decimal. E.g. -0.1283983. Returns an empty string if no location data is available. Otherwise, a number is returned",
          "format": "double",
          "type": "number"
        },
        "northings": {
          "description": "Northings reference using the Ordnance Survey National Grid reference system. Northern Ireland Northings uses the Irish Grid Reference System. Metres from origin. E.g. 180458. Returns an empty string if no location data is available. Otherwise a number is returned",
          "format": "int32",
          "type": "integer"
        },
        "organisation_name": {
          "description": "Name of the organisation registered at this address.",
          "maxLength": 60,
          "type": "string"
        },
        "po_box": {
          "description": "When the PO Box Number field is populated it will contain PO BOX nnnnnn where n represents the PO Box number. Note that the PO Box details can occasionally consist of a combination of numbers and letters e.g. HK860. PO Box Numbers are only allocated to Large Users.",
          "type": "string"
        },
        "post_town": {
          "description": "A Post Town is mandatory for delivery of mail to a Delivery Point. This is not necessarily the nearest town geographically, but a routing instruction to the Royal Mail delivery office sorting mail for that Delivery Point. A Post Town will always be present in every address, and for some Localities the Post Town will be the only locality element present.",
          "maxLength": 30,
          "type": "string"
        },
        "postal_county": {
          "description": "Postal counties were used for the distribution of mail before the Postcode system was introduced in the 1970s. The Former Postal County was the Administrative County at the time. This data rarely changes. Data source: Royal Mail. May be empty.",
          "type": "string"
        },
        "postcode": {
          "description": "Correctly formatted postcode. Capitalised and spaced.",
          "type": "string"
        },
        "postcode_inward": {
          "description": "The second part of a postcode is known as the inward Code. e.g. The inward code of ID1 1QD is 1QD. This part is one number followed by two letters. The number identifies the sector in the postal district. The letters then define one or more properties in that sector.",
          "type": "string"
        },
        "postcode_outward": {
          "description": "The first part of a postcode is known as the outward code. e.g. The outward code of ID1 1QD is ID1. Enables mail to be sorted to the correct local area for delivery. This part of the code contains the area and the district to which the mail is to be delivered, e.g. \u2018PO1\u2019, \u2018SW1A\u2019 or \u2018B23\u2019.",
          "type": "string"
        },
        "postcode_type": {
          "$ref": "#/definitions/PostcodeType"
        },
        "premise": {
          "description": "A pre-computed string which sensibly combines building_number, building_name and sub_building_name. building_number, building_name and sub_building_name represent raw data from Royal Mail's and can be difficult to parse if you are unaware of how the Postcode Address File premise fields work together. For this reason, we also provide a pre-computed premise field which intelligently gathers these points into a single, simple premise string. This field is ideal if you want to pull premise information and thoroughfare information separately instead of using our address lines data.",
          "maxLength": 84,
          "type": "string"
        },
        "su_organisation_indicator": {
          "description": "Small User Organisation Indicator can have the values 'Y' or space. A value of 'Y' indicates that a Small User Organisation is present at this address.",
          "type": "string"
        },
        "sub_building_name": {
          "description": "When a premise is split into individual units such as flats, apartments or business units. Cannot be present without either building_name or building_number. E.g. Flat 1, A, 10B",
          "maxLength": 30,
          "type": "string"
        },
        "thoroughfare": {
          "description": "Also known as the street or road name. In general each Thoroughfare Name will have a separate Postcode. Longer Thoroughfares with high number ranges often have multiple Postcodes covering the entire length of the road, with breaks at suitable points e.g. junctions or natural breaks in the road.",
          "maxLength": 80,
          "type": "string"
        },
        "traditional_county": {
          "description": "Traditional counties are provided by the Association of British Counties. It\u2019s historical data, and can date from the 1800s. Data source: Royal Mail. May be empty.",
          "type": "string"
        },
        "udprn": {
          "description": "UDPRN stands for \u2018Unique Delivery Point Reference Number\u2019. Royal Mail assigns a unique UDPRN code for each premise on PAF. Simple, unique reference number for each Delivery Point. Unlikely to be reused when an address expires. Up to 8-digit numeric code. A new UDPRN is automatically assigned to each new Delivery Point added to PAF.",
          "format": "int32",
          "type": "integer"
        },
        "umprn": {
          "description": "A small minority of individual premises (as identified by a UDPRN) may have multiple occupants behind the same letterbox. These are known as Multiple Residence occupants and can be queried via the Multiple Residence dataset. Simple, unique reference number for each Multiple Residence occupant. 8-character numeric code. Note: this will be an empty string when not used for legacy reasons",
          "type": "string"
        },
        "ward": {
          "description": "The current administrative/electoral area to which the postcode has been assigned. May be empty for a small number of addresses. Data source: ONS",
          "type": "string"
        }
      },
      "title": "Address",
      "type": "object"
    },
    "AddressAutocompleteHit": {
      "properties": {
        "suggestion": {
          "description": "Suggestion for your given query, represented as a partial address.",
          "type": "string"
        },
        "udprn": {
          "description": "Represents the UDPRN of a premise",
          "type": "string"
        },
        "umprn": {
          "description": "Optionally returned field, representing the UMPRN of a Multiple Residence household",
          "type": "string"
        },
        "urls": {
          "$ref": "#/definitions/AddressAutocompleteHitUrls"
        }
      },
      "title": "AddressAutocompleteHit",
      "type": "object"
    },
    "AddressAutocompleteHitUrls": {
      "properties": {
        "udprn": {
          "description": "URL to retrieve the entire details for a given address suggestion",
          "type": "string"
        },
        "umprn": {
          "description": "Optionally returned field, to retrieve the entire details for a suggested Multiple Residence household",
          "type": "string"
        }
      },
      "title": "AddressAutocompleteHitUrls",
      "type": "object"
    },
    "AddressAutocompleteResponseSchema": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/AddressAutocompleteResult"
        }
      },
      "title": "AddressAutocompleteResponseSchema",
      "type": "object"
    },
    "AddressAutocompleteResult": {
      "properties": {
        "hits": {
          "items": {
            "$ref": "#/definitions/AddressAutocompleteHit"
          },
          "type": "array"
        }
      },
      "title": "AddressAutocompleteResult",
      "type": "object"
    },
    "AddressLookupResponseSchema": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/Address"
        }
      },
      "title": "AddressLookupResponseSchema",
      "type": "object"
    },
    "AddressSearchResponseSchema": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/AddressSearchResult"
        }
      },
      "title": "AddressSearchResponseSchema",
      "type": "object"
    },
    "AddressSearchResult": {
      "properties": {
        "hits": {
          "items": {
            "$ref": "#/definitions/Address"
          },
          "type": "array"
        },
        "limit": {
          "format": "int32",
          "maximum": 0,
          "minimum": 0,
          "type": "integer"
        },
        "page": {
          "format": "int32",
          "minimum": 0,
          "type": "integer"
        },
        "total": {
          "format": "int32",
          "minimum": 0,
          "type": "integer"
        }
      },
      "title": "AddressSearchResult",
      "type": "object"
    },
    "AutomatedTopup": {
      "properties": {
        "enabled": {
          "type": "boolean"
        }
      },
      "title": "AutomatedTopup",
      "type": "object"
    },
    "CreateLicenseeDaily": {
      "properties": {
        "limit": {
          "description": "The maximum number of lookups this licensee can perform in a day. Set to `null` to deactivate the limit",
          "format": "double",
          "type": "number"
        }
      },
      "title": "CreateLicenseeDaily",
      "type": "object"
    },
    "CreateLicenseeSchema": {
      "properties": {
        "address": {
          "description": "Licensee's first, second and third line address as well as post town concatenated by commas",
          "type": "string"
        },
        "daily": {
          "$ref": "#/definitions/CreateLicenseeDaily"
        },
        "name": {
          "description": "Licensee individual or organisation name",
          "type": "string"
        },
        "postcode": {
          "description": "Licensee's postcode",
          "type": "string"
        },
        "whitelist": {
          "description": "A whitelist of authorised URLs. An empty list means that whitelisting is disabled",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "name",
        "address",
        "postcode"
      ],
      "title": "CreateLicenseeSchema",
      "type": "object"
    },
    "CurrentPurchase": {
      "properties": {
        "consumed": {
          "description": "Number of consumed lookups off this purchase.",
          "format": "int32",
          "minimum": 0,
          "type": "integer"
        },
        "expires": {
          "description": "`string` or `null` The date when this purchase will expire in simplified \nextended ISO format (ISO 8601). This is typically 365 days from the time \nof first use. This field will be `null` if the purchase has not yet been \nused.",
          "type": "string"
        },
        "purchased": {
          "description": "Number of procured lookups from this purchase.",
          "format": "int32",
          "minimum": 0,
          "type": "integer"
        }
      },
      "title": "CurrentPurchase",
      "type": "object"
    },
    "DeleteLicenseeResponseSchema": {
      "properties": {
        "result": {
          "$ref": "#/definitions/DeleteLicenseeResult"
        }
      },
      "title": "DeleteLicenseeResponseSchema",
      "type": "object"
    },
    "DeleteLicenseeResult": {
      "properties": {
        "deleted": {
          "description": "Number of licensees deleted.",
          "format": "double",
          "minimum": 0,
          "type": "number"
        }
      },
      "title": "DeleteLicenseeResult",
      "type": "object"
    },
    "ErrorResponseSchema": {
      "properties": {
        "code": {
          "description": "API Response Code. Non `2xxx` code indicates a failure. This code will provide a more specific reason when a failure occurs and facilitates debugging.",
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "description": "Human readable error message supplied with every error response.",
          "type": "string"
        }
      },
      "title": "ErrorResponseSchema",
      "type": "object"
    },
    "GeolocationToPostcode": {
      "properties": {
        "distance": {
          "format": "double",
          "type": "number"
        },
        "eastings": {
          "description": "Eastings reference using the Ordnance Survey National Grid reference system. Northern Ireland Eastings uses the Irish Grid Reference System. Metres from origin. E.g. 550458. Returns an empty string if no location data is available. Otherwise a number is returned",
          "format": "int32",
          "type": "integer"
        },
        "latitude": {
          "description": "The latitude of the postcode (WGS84/ETRS89). Accurate at the postcode level Can be a positive or negative decimal. E.g. 51.5083983. Returns an empty string if no location data is available. Otherwise a number is returned",
          "format": "double",
          "type": "number"
        },
        "longitude": {
          "description": "The longitude of the postcode (WGS84/ETRS89). Accurate at the postcode level. Can be a positive or negative decimal. E.g. -0.1283983. Returns an empty string if no location data is available. Otherwise, a number is returned",
          "format": "double",
          "type": "number"
        },
        "northings": {
          "description": "Northings reference using the Ordnance Survey National Grid reference system. Northern Ireland Northings uses the Irish Grid Reference System. Metres from origin. E.g. 180458. Returns an empty string if no location data is available. Otherwise a number is returned",
          "format": "int32",
          "type": "integer"
        },
        "postcode": {
          "description": "Correctly formatted postcode. Capitalised and spaced.",
          "type": "string"
        }
      },
      "title": "GeolocationToPostcode",
      "type": "object"
    },
    "GeolocationToPostcodesResponseSchema": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "limit": {
          "description": "Maximum number of results per request. Fixed at 100 for this method",
          "format": "double",
          "type": "number"
        },
        "message": {
          "type": "string"
        },
        "page": {
          "description": "Indicates current page number.",
          "format": "double",
          "type": "number"
        },
        "result": {
          "items": {
            "$ref": "#/definitions/GeolocationToPostcode"
          },
          "type": "array"
        },
        "total": {
          "description": "Indicates the maximum number of delivery points plus residences at this postcode.",
          "format": "double",
          "type": "number"
        }
      },
      "title": "GeolocationToPostcodesResponseSchema",
      "type": "object"
    },
    "KeyDailyLimit": {
      "properties": {
        "consumed": {
          "description": "Number of lookups performed today which count towards your daily limit.",
          "format": "int32",
          "minimum": 0,
          "type": "integer"
        },
        "limit": {
          "description": "`number` or `null`. The daily lookup limit currently set on your key. \n`null` means the limit is currently disabled.",
          "format": "int32",
          "minimum": 0,
          "type": "integer"
        }
      },
      "title": "KeyDailyLimit",
      "type": "object"
    },
    "KeyDetailsResponseSchema": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/KeyDetailsResult"
        }
      },
      "title": "KeyDetailsResponseSchema",
      "type": "object"
    },
    "KeyDetailsResult": {
      "properties": {
        "allowed_urls": {
          "description": "A whitelist of authorised URLs. An empty list means that whitelisting is disabled",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "automated_topups": {
          "$ref": "#/definitions/AutomatedTopup"
        },
        "current_purchases": {
          "items": {
            "$ref": "#/definitions/CurrentPurchase"
          },
          "type": "array"
        },
        "daily_limit": {
          "$ref": "#/definitions/KeyDailyLimit"
        },
        "individual_limit": {
          "$ref": "#/definitions/KeyIndividualLimit"
        },
        "lookups_remaining": {
          "format": "int32",
          "minimum": 0,
          "type": "integer"
        },
        "notifications": {
          "$ref": "#/definitions/Notifications"
        }
      },
      "title": "KeyDetailsResult",
      "type": "object"
    },
    "KeyIndividualLimit": {
      "properties": {
        "consumed": {
          "description": "`number` or `null` Limit set on the number of lookups that can be \nperformed from a single IP address. `null` means the limit is currently \ndisabled.",
          "format": "int32",
          "minimum": 0,
          "type": "integer"
        }
      },
      "title": "KeyIndividualLimit",
      "type": "object"
    },
    "KeyUsabilityResponseSchema": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/KeyUsabilityResult"
        }
      },
      "title": "KeyUsabilityResponseSchema",
      "type": "object"
    },
    "KeyUsabilityResult": {
      "properties": {
        "available": {
          "type": "boolean"
        }
      },
      "title": "KeyUsabilityResult",
      "type": "object"
    },
    "KeyUsageDailyCountEpoch": {
      "properties": {
        "count": {
          "description": "An array of objects representing number of paid lookups made on specific days, ordered by date. Each object contains a `date` attribute, which represents the day and a `count` attribute, which represents the number of paid lookups made on that day.",
          "format": "int32",
          "type": "integer"
        },
        "date": {
          "type": "string"
        }
      },
      "title": "KeyUsageDailyCountEpoch",
      "type": "object"
    },
    "KeyUsageResponseSchema": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/KeyUsageResult"
        }
      },
      "title": "KeyUsageResponseSchema",
      "type": "object"
    },
    "KeyUsageResult": {
      "properties": {
        "dailyCount": {
          "items": {
            "$ref": "#/definitions/KeyUsageDailyCountEpoch"
          },
          "type": "array"
        },
        "end": {
          "description": "End date in ISO 8601 format.",
          "type": "string"
        },
        "start": {
          "description": "Start date in ISO 8601 format.",
          "type": "string"
        },
        "total": {
          "description": "Total of paid lookups performed in specified period.",
          "format": "int32",
          "type": "integer"
        }
      },
      "title": "KeyUsageResult",
      "type": "object"
    },
    "Licensee": {
      "properties": {
        "address": {
          "description": "Licensee's first, second and third line address as well as post town concatenated by commas",
          "type": "string"
        },
        "createdAt": {
          "description": "Timestamp for when the licensee was created",
          "type": "string"
        },
        "daily": {
          "$ref": "#/definitions/LicenseeDaily"
        },
        "id": {
          "description": "An immutable ID provided for every licensee. Primarily used for paginated list requests",
          "type": "string"
        },
        "key": {
          "description": "Uniquely identifies a licensee for a key. Required to perform paid lookups for a specific licensee",
          "type": "string"
        },
        "name": {
          "description": "Licensee individual or organisation name",
          "type": "string"
        },
        "postcode": {
          "description": "Licensee's postcode",
          "type": "string"
        },
        "whitelist": {
          "description": "A whitelist of authorised URLs. An empty list means that whitelisting is disabled",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "title": "Licensee",
      "type": "object"
    },
    "LicenseeDaily": {
      "properties": {
        "count": {
          "description": "The number lookups performed by the licensee on the day represented b `licesees.daily.updatedAt`",
          "format": "double",
          "minimum": 0,
          "type": "number"
        },
        "limit": {
          "description": "The maximum number of lookups this licensee can perform in a day. null indicates the limit is not active",
          "format": "double",
          "minimum": 0,
          "type": "number"
        },
        "updatedAt": {
          "description": "The timestamp when the limit was last used.",
          "type": "string"
        }
      },
      "title": "LicenseeDaily",
      "type": "object"
    },
    "LicenseeListResponseSchema": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/LicenseeListResult"
        }
      },
      "title": "LicenseeListResponseSchema",
      "type": "object"
    },
    "LicenseeListResult": {
      "properties": {
        "hasMore": {
          "description": "Returns true if there are more licensees listed after the maximum number of results as implied by `limit`",
          "type": "boolean"
        },
        "licensees": {
          "items": {
            "$ref": "#/definitions/Licensee"
          },
          "type": "array"
        }
      },
      "title": "LicenseeListResult",
      "type": "object"
    },
    "LicenseeResponseSchema": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/Licensee"
        }
      },
      "title": "LicenseeResponseSchema",
      "type": "object"
    },
    "Notifications": {
      "properties": {
        "emails": {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "enabled": {
          "type": "boolean"
        }
      },
      "title": "Notifications",
      "type": "object"
    },
    "PostcodeToAddressResponseSchema": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "type": "string"
        },
        "result": {
          "items": {
            "$ref": "#/definitions/Address"
          },
          "type": "array"
        }
      },
      "title": "PostcodeToAddressResponseSchema",
      "type": "object"
    },
    "PostcodeType": {
      "description": "This indicates the type of user. It can only take the values 'S' or 'L' indicating small or large respectively. Large User Postcodes. These are assigned to one single address either due to the large volume of mail received at that address, or because a PO Box or Selectapost service has been set up. Small User Postcodes. These identify a group of Delivery Points. On average there are 15 Delivery Points per Postcode. However this can vary between 1 and, in some cases, 100. There will never be more than 100 Delivery Points on a Postcode.",
      "enum": [
        "S",
        "L"
      ],
      "example": "S",
      "title": "PostcodeType",
      "type": "string"
    },
    "UDPRNToAddressResponseSchema": {
      "properties": {
        "code": {
          "format": "int32",
          "type": "integer"
        },
        "message": {
          "type": "string"
        },
        "result": {
          "$ref": "#/definitions/Address"
        }
      },
      "title": "UDPRNToAddressResponseSchema",
      "type": "object"
    },
    "UpdateLicenseeSchema": {
      "properties": {
        "address": {
          "description": "Licensee's first, second and third line address as well as post town concatenated by commas",
          "type": "string"
        },
        "daily": {
          "$ref": "#/definitions/CreateLicenseeDaily"
        },
        "postcode": {
          "description": "Licensee's postcode",
          "type": "string"
        },
        "whitelist": {
          "description": "A whitelist of authorised URLs. An empty list means that whitelisting is disabled",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "title": "UpdateLicenseeSchema",
      "type": "object"
    }
  },
  "host": "api.ideal-postcodes.co.uk",
  "info": {
    "contact": {
      "email": "support@ideal-postcodes.co.uk"
    },
    "description": "Open API spec for Ideal Postcodes API (api.ideal-postcodes.co.uk)",
    "title": "IdealPostcodes API",
    "version": "1.0.0"
  },
  "paths": {
    "/addresses": {
      "get": {
        "deprecated": false,
        "description": "Returns a list of addresses that match the query ordered by relevance score.\nThis query accepts an optional limit and page query (defaults to 10 and 0 respectively).\n\nIf a valid postcode is passed as the query string, the entire address list\nfor that postcode is returned as the result. Note, in these cases, limit\nparameter is ignored and fixed at 100. If your key is configured to return\nMultiple Residence data, you may need to query more pages to return the\nentire list as more than 100 delivery points or residences may be returned.\n\n### Testing\n\n- **ID1 1QD** Returns a successful query response `2000`\n- **ID1 KFA** Returns an empty query response `2000`\n- **ID1 CLIP** Returns \"no lookups remaining\" error `4020`\n- **ID1 CHOP** Returns \"daily (or individual) lookup limit breached\" error `4021`\n\nTest requests will undergo usual authentication and restriction rules (individual and daily lookup limits) to surface any problems you may have during implementation. However, it will not count towards a postcode lookup on your key.\n\n### Notes\n\nThis is not an address autocomplete method. Each request that returns an address incurs a lookup charge.\n\nIf a valid postcode is passed as the query string, the entire address list for that postcode is passed as a result. Note, in these cases, limit and page parameters are ignored.\n\n### Pricing\n\nPer lookup charges apply. Queries which find no match are not charged.\n\n### Data Source\n\nRoyal Mail (Postcode Address File), Ordnance Survey (Code-Point Open).\n",
        "operationId": "AddressesGet",
        "parameters": [
          {
            "description": "Specifies the address you wish to query. Query can be shortened to `q=`",
            "in": "query",
            "name": "query",
            "required": true,
            "type": "string"
          },
          {
            "default": 10,
            "description": "Specifies the upper limit on the number of address results to be returned. Max is 100 addresses. Query can be shortened to `l=`",
            "exclusiveMaximum": false,
            "exclusiveMinimum": false,
            "format": "int32",
            "in": "query",
            "maximum": 100,
            "minimum": 0,
            "name": "limit",
            "required": false,
            "type": "integer"
          },
          {
            "default": 0,
            "description": "Specifies the page of results to be returned. Query can be shortened to `p=`",
            "exclusiveMaximum": false,
            "exclusiveMinimum": false,
            "format": "int32",
            "in": "query",
            "minimum": 0,
            "name": "page",
            "required": false,
            "type": "integer"
          },
          {
            "description": "Comma separated whitelist of address elements to return. E.g. `filter=line_1,line_2,line_3` returns only `line_1`, `line_2 and `line_3` address elements in your response",
            "in": "query",
            "name": "filter",
            "required": false,
            "type": "string"
          },
          {
            "description": "Comma separated list of outward codes with which to restrict result set. E.g. `postcode_outward=sw1a`, `postcode_outward=tr8,le18`",
            "in": "query",
            "name": "postcode_outward",
            "required": false,
            "type": "string"
          },
          {
            "description": "Only required if you are using a sublicensed key. This parameter will associate the request with your licensee",
            "in": "query",
            "name": "licensee",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/AddressSearchResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "AddressSearch",
        "tags": [
          "Addresses"
        ]
      }
    },
    "/addresses/{udprn}": {
      "get": {
        "deprecated": false,
        "description": "### Returns an address identified via its UDPRN.\n\nYou may find it useful to store UDPRN information as it can be used to retrieve the most recent information for an address. It can also be used to test for a \"decommissioned\" address.\n\n### Testing\n\nTo test your implementation of our API we have a range of test UDPRNs that yield both successful and unsuccessful responses to your request. They are the following:\n\n- `0` Returns a successful UDPRN lookup response `2000`\n- `-1` Returns \"UDPRN not found\", error `4044`\n- `-2` Returns \"no lookups remaining\", error `4020`\n- `-3` Returns \"daily (or individual) lookup limit breached\", error `4021`\n\nTest requests will undergo usual authentication and restriction rules (individual and daily lookup limits) to surface any problems you may have during implementation. However, it will not count towards a postcode lookup on your key.\n\n### Pricing\n\nPer lookup charges apply. Empty responses are not charged.\n\n### Data Source\n\nRoyal Mail (Postcode Address File), Ordnance Survey (Code-Point Open).\n",
        "operationId": "AddressesByUdprnGet",
        "parameters": [
          {
            "description": "UDPRNs are an eight digit unique numeric code (e.g. 25962203) for any premise on the Postcode Address File. It's essentially a unique identifier for every address in the UK that Royal Mail has in its database.",
            "in": "path",
            "name": "udprn",
            "required": true,
            "type": "string"
          },
          {
            "description": "Comma separated whitelist of address elements to return. E.g. `filter=line_1,line_2,line_3` returns only `line_1` `line_2` and `line_3` address elements in your response",
            "in": "query",
            "name": "filter",
            "required": false,
            "type": "string"
          },
          {
            "description": "Only required if you are using a sublicensed key. This parameter will associate the request with your licensee",
            "in": "query",
            "name": "licensee",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/UDPRNToAddressResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "UpdrnToAddress",
        "tags": [
          "Addresses"
        ]
      }
    },
    "/autocomplete/addresses": {
      "get": {
        "deprecated": false,
        "description": "Use `/autocomplete` to retrieve address suggestions for a partial string.\n\n### Implementing Autocomplete\n\nRetrieving addresses using autocomplete is a 2 step process.\n\n1. Retrieve partial address suggestions via `/autocomplete/addresses`\n2. Retrieve the entire address by following the URL provided by the suggestion\n\nStep 2 will decrement your lookup balance.\n\nPlease note, this API is [not intended to be a free standalone resource](#pricing).\n\n### Testing\n\n`ID1 1QD` will return address suggestions, that when retrieved via `/udprn/:id` will not affect your balance.\n\n### Notes\n\n#### Suggestion Format\n\nThe suggestion format is prone to change over time. Attempts to parse the suggestion may result in your integration breaking. Instead use the suggestion as is.\n\n#### Querying with a Postcode\n\nIf a postcode is passed as a query, all addresses for that postcode will be listed as the result if the limit parameter is not supplied. If a postcode forms only part of the query, your autocomplete results will be filtered by that postcode.\n\n#### Authentication\n\nWhen using the autocomplete API, low request latency is essential in delivering a speedy list of suggestions to the user. For this reason we recommend using query string authentication (i.e. `api_key=foo`) rather than HTTP Header authentication (i.e. `Authorization: IDEALPOSTCODES api_key=\"foo\"`). The latter will incur additional latency as most browsers will trigger a preflight OPTIONS request for each key press.\n\n#### Querying Multiple Residence\n\nFor Multiple Residence enabled keys, any Multiple Residence households will also return a UMPRN id, which can be retrieved with the `/umprn/` endpoint. Note that Multiple Residence households will always have a parent premise with a UDPRN, and a single UDPRN premise may have many Multiple Residence households with different UMPRNs. For instance:\n\n```\n{\n  \"result\": {\n    \"hits\": [\n      {\n        \"suggestion\": \"10 Downings, London, E6\",\n        \"urls\": {\n          \"udprn\": \"/v1/udprn/7944730\"\n        },\n        \"udprn\": 7944730\n      },\n      {\n        \"suggestion\": \"10 Downing Grove, Hull, HU9\",\n        \"urls\": {\n          \"udprn\": \"/v1/udprn/11168744\",\n          \"umprn\": \"/v1/umprn/882919\"\n        },\n        \"udprn\": 11168744,\n        \"umprn\": 882919\n      }\n    ]\n  },\n  \"code\": 2000,\n  \"message\": \"Success\"\n}\n```\n\n### Rate Limiting\n\nYou can make up to 3000 requests to the autocomplete API within a 5 minute span. The HTTP Header contains information on your current rate limit.\n\n| Header                  | Description |\n| ----------------------- | -------------------------------------------------------------------------------------- |\n| `X-RateLimit-Limit`     | The maximum number of requests that can be made in 5 minutes                           |\n| `X-RateLimit-Remaining` | The remaining requests within the current rate limit window                            |\n| `X-RateLimit-Reset`     | The time when the rate limit window resets in Unix Time (seconds) or UTC Epoch seconds |\n\n### Pricing\n\nThis API currently does not affect your balance. However, subsequent searches require a paid request (e.g. a UDPRN search). This paid request, will yield the complete address.\n\nPlease note, this API is not intended as a standalone free resource. Integrations that consistently make autocomplete requests without a paid request to resolve an address may be disrupted via tightened rate limits. Continued misuse will result in account suspension.\n\n### Data Source\n\nRoyal Mail (Postcode Address File).\n",
        "operationId": "AutocompleteAddressesGet",
        "parameters": [
          {
            "description": "Specifies the address you wish to query. Query can be shortened to `q=`",
            "in": "query",
            "name": "query",
            "required": true,
            "type": "string"
          },
          {
            "description": "Only required if you are using a sublicensed key. This parameter will associate the request with your licensee",
            "in": "query",
            "name": "licensee",
            "required": false,
            "type": "string"
          },
          {
            "default": 10,
            "description": "Specifies the maximum number of suggestions to retrieve. Range must be 1-100. By default the limit is 10, unless a postcode is queried (then all addresses at that postcode will be returned). Limit can be shortened to `l=`",
            "exclusiveMaximum": false,
            "exclusiveMinimum": false,
            "format": "int32",
            "in": "query",
            "maximum": 100,
            "minimum": 1,
            "name": "limit",
            "required": false,
            "type": "integer"
          },
          {
            "description": "Comma separated list of outward codes with which to restrict result set. E.g. `postcode_outward=sw1a`, `postcode_outward=tr8,le18`",
            "in": "query",
            "name": "postcode_outward",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/AddressAutocompleteResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "AddressAutocomplete",
        "tags": [
          "Autocomplete"
        ]
      }
    },
    "/keys/{key}": {
      "get": {
        "deprecated": false,
        "description": "Currently returns whether the key is useable via the `available` property.\nYou may Use this method to discover if the key is useable before making\nfurther requests.\n\nWhen the `user_token` is not provided, this API returns public information on key. \n\n### Testing\n\nTo test your implementation of our API, you may use the following test keys.\n\n- **iddqd** Availability will return as `true`\n- **idkfa** Availability will return as `false`\n",
        "operationId": "KeysByKeyGet",
        "parameters": [
          {
            "description": "",
            "in": "path",
            "name": "key",
            "required": true,
            "type": "string"
          },
          {
            "description": "",
            "in": "query",
            "name": "user_token",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/KeyUsabilityResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "CheckKeyUsability",
        "tags": [
          "Keys"
        ]
      }
    },
    "/keys/{key}/licensees": {
      "get": {
        "deprecated": false,
        "description": "Returns a list of licensees for a key.",
        "operationId": "KeysLicenseesByKeyGet",
        "parameters": [
          {
            "description": "",
            "in": "path",
            "name": "key",
            "required": true,
            "type": "string"
          },
          {
            "description": "Specify ID of the licensee after which you would like to list results",
            "exclusiveMaximum": false,
            "exclusiveMinimum": false,
            "format": "int32",
            "in": "query",
            "name": "starting_after",
            "required": false,
            "type": "integer"
          },
          {
            "description": "Specify the maximum number of results to return per page. Default and maximum is `100`.",
            "exclusiveMaximum": false,
            "exclusiveMinimum": false,
            "format": "int32",
            "in": "query",
            "maximum": 100,
            "minimum": 0,
            "name": "limit",
            "required": false,
            "type": "integer"
          },
          {
            "description": "Filter result by licensee name. Query can be shortened to `q=`",
            "in": "query",
            "name": "query",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/LicenseeListResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "ListLicensees",
        "tags": [
          "Licensees"
        ]
      },
      "post": {
        "deprecated": false,
        "description": "Create a licensee for the specified API Key.",
        "operationId": "KeysLicenseesByKeyPost",
        "parameters": [
          {
            "description": "",
            "in": "path",
            "name": "key",
            "required": true,
            "type": "string"
          },
          {
            "description": "",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateLicenseeSchema"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/LicenseeResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "CreateLicensee",
        "tags": [
          "Licensees"
        ]
      },
      "put": {
        "deprecated": false,
        "description": "Update particulars for a licensee",
        "operationId": "KeysLicenseesByKeyPut",
        "parameters": [
          {
            "description": "",
            "in": "path",
            "name": "key",
            "required": true,
            "type": "string"
          },
          {
            "description": "",
            "in": "body",
            "name": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/UpdateLicenseeSchema"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/LicenseeResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {}
          },
          "402": {
            "description": "Request failed",
            "schema": {}
          },
          "404": {
            "description": "Resource not found",
            "schema": {}
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {}
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "UpdateLicensee",
        "tags": [
          "Licensees"
        ]
      }
    },
    "/keys/{key}/licensees/{licensee_key}": {
      "delete": {
        "deprecated": false,
        "description": "Cancels a licensee key. This renders a licensee unusable. This action can be reversed if you get in contact with us.",
        "operationId": "KeysLicenseesByKeyAndLicenseeKeyDelete",
        "parameters": [
          {
            "description": "",
            "in": "path",
            "name": "key",
            "required": true,
            "type": "string"
          },
          {
            "description": "",
            "in": "path",
            "name": "licensee_key",
            "required": true,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/DeleteLicenseeResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "DeleteLicensee",
        "tags": [
          "Licensees"
        ]
      },
      "get": {
        "deprecated": false,
        "description": "Returns licensee information as identified by the licensee key.",
        "operationId": "KeysLicenseesByKeyAndLicenseeKeyGet",
        "parameters": [
          {
            "description": "",
            "in": "path",
            "name": "key",
            "required": true,
            "type": "string"
          },
          {
            "description": "",
            "in": "path",
            "name": "licensee_key",
            "required": true,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/LicenseeResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "RetrieveLicensee",
        "tags": [
          "Licensees"
        ]
      }
    },
    "/keys/{key}/lookups": {
      "get": {
        "deprecated": false,
        "description": "Returns a CSV download of lookups performed and associated information.\n\nNote that the `Content-Type` returned will be CSV (text/csv). For a non 200\nresponse, the `Content-Type` will revert to JSON with the error code and\nmessage embedded.\n\nThis method requires a `user_token`, which can be found on your [accounts page](https://ideal-postcodes.co.uk/account).\n\nA maximum interval of 90 days can be provided for analysis. If no start or end date is provided, the last 21 days will be used as the default interval.\n\n### GDPR Update\n\nAfter May 2018, the API will begin to redact IP Address, Search Term and URL data that is older than 28 days from our stores on a weekly basis as part of our new data protection strategy. This means the aforementioned data points will no longer be retrievable from this API if it is more than 28 days old.\n\nReach out to us by [mail](<mailto:support@ideal-postcodes.co.uk>) or [chat](https://chat.ideal-postcodes.co.uk) if you would like to modify this 28 day window or prefer this data not be collected at all.\n",
        "operationId": "KeysLookupsByKeyGet",
        "parameters": [
          {
            "description": "",
            "in": "path",
            "name": "key",
            "required": true,
            "type": "string"
          },
          {
            "description": "An start date/time in the form of a UNIX Timestamp in milliseconds, e.g. 1418556452651. If no start time is provided, the start time will be assigned to a time 21 days prior to the end time.",
            "exclusiveMaximum": false,
            "exclusiveMinimum": false,
            "format": "int32",
            "in": "query",
            "name": "start",
            "required": false,
            "type": "integer"
          },
          {
            "description": "An end date/time in the form of a UNIX Timestamp in milliseconds, e.g. 1418556452651. If no end time is provided, the current time will be used.",
            "exclusiveMaximum": false,
            "exclusiveMinimum": false,
            "format": "int32",
            "in": "query",
            "name": "end",
            "required": false,
            "type": "integer"
          },
          {
            "description": "Sublicensed keys only. This will restrict the analysed dataset to a specific licensee.",
            "in": "query",
            "name": "licensee",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "type": "string"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "DownloadUsageHistory",
        "tags": [
          "Keys"
        ]
      }
    },
    "/keys/{key}/usage": {
      "get": {
        "deprecated": false,
        "description": "Reports the number of lookups consumed on a key for a range of days.\n\nThis method requires a `user_token`, which can be found on your [accounts page](https://ideal-postcodes.co.uk/account).\n\nA maximum interval of 90 days can be provided for analysis. If no start or\nend date is provided, the last 21 days will be used as the default interval.\n",
        "operationId": "KeysUsageByKeyGet",
        "parameters": [
          {
            "description": "",
            "in": "path",
            "name": "key",
            "required": true,
            "type": "string"
          },
          {
            "description": "A start date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no start time is provided, the start time will be assigned to a time 21 days prior to the end time.",
            "exclusiveMaximum": false,
            "exclusiveMinimum": false,
            "format": "int32",
            "in": "query",
            "name": "start",
            "required": false,
            "type": "integer"
          },
          {
            "description": "An end date/time in the form of a UNIX Timestamp in milliseconds, e.g. `1418556452651`. If no end time is provided, the current time will be used.",
            "exclusiveMaximum": false,
            "exclusiveMinimum": false,
            "format": "int32",
            "in": "query",
            "name": "end",
            "required": false,
            "type": "integer"
          },
          {
            "description": "An comma separated list of tags you wish to query for. This is useful if you want to specify the circumstances in which the request was made. If multiple tags are specified, the analysed dataset will only comprise of requests for which all the tags are satisfied - i.e. searching `foo,bar` will only query requests which tagged both `'foo'` and `'bar'`.",
            "in": "query",
            "name": "tags",
            "required": false,
            "type": "string"
          },
          {
            "description": "Sublicensed keys only. This will restrict the analysed dataset to a specific licensee.",
            "in": "query",
            "name": "licensee",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/KeyUsageResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "MonitorKeyUsage",
        "tags": [
          "Keys"
        ]
      }
    },
    "/postcodes/{postcode}": {
      "get": {
        "deprecated": false,
        "description": "Returns the complete list of addresses for a postcode.\n\nPostcode searches are space and case insensitive.\n\n### Postcode not found\n\nPlease note: For postcodes that do not exist, your key is not charged, the API returns a 404 response with a response body\n\n```\n{\n  \"code\": 4040,\n  \"message\": \"Postcode not found\"\n}\n```\n\n### Testing\n\nTo test your implementation of our API we have a range of test postcodes that yield both successful and unsuccessful responses to your request. They are the following:\n\n- `ID1 1QD` Returns a successful postcode lookup response `2000`\n- `ID1 KFA` Returns \"postcode not found\", error `4040`\n- `ID1 CLIP` Returns \"no lookups remaining\", error `4020`\n- `ID1 CHOP` Returns \"daily (or individual) lookup limit breached\", error `4021`\n\nTest requests will undergo usual authentication and restriction rules (individual and daily lookup limits) to surface any problems you may have during implementation. However, it will not count towards a postcode lookup on your key.\n\n### Multiple Residence Dataset & Pagination\n\nFor keys which use the Multiple Residence dataset, there are a small number of postcodes which yield more than Royal Mail's maximum allowed return (of 100 addresses) per request. Multiple Residence data users have the option of paginating postcode queries if the limit is reached.\n\n#### Multiple Residence: Additional Query Parameters\n\n| Property | Description                                                                          |\n| -------- | ------------------------------------------------------------------------------------ |\n| `page`   | 0 indexed indicator of the page of results to receive. Defaults to `0`               |\n\n#### Multiple Residence: Additional Response Fields\n\n| Property | Description                                                                               |\n| -------- | ----------------------------------------------------------------------------------------- |\n| `page`   | `number` Indicates current page number                                                    |\n| `total`  | `number` Indicates the maximum number of delivery points plus residences at this postcode |\n| `limit`  | `number` Maximum number of results per request. Fixed at 100 for this method              |\n\n### Pricing\n\nPer lookup charges are applied. Empty responses are not charged.\n\n### Data Source\n\nRoyal Mail (Postcode Address File), Ordnance Survey (Code-Point Open).\n",
        "operationId": "PostcodesByPostcodeGet",
        "parameters": [
          {
            "description": "",
            "in": "path",
            "name": "postcode",
            "required": true,
            "type": "string"
          },
          {
            "description": "Comma separated whitelist of address elements to return. E.g.  `filter=line_1,line_2,line_3` returns only `line_1` `line_2` and `line_3` address elements in your response",
            "in": "query",
            "name": "filter",
            "required": false,
            "type": "string"
          },
          {
            "description": "Only required if you are using a sublicensed key. This parameter will associate the request with your licensee",
            "in": "query",
            "name": "licensee",
            "required": false,
            "type": "string"
          },
          {
            "default": 0,
            "description": "Only available for use with the multiple residence dataset.\nThis is a 0 indexed indicator of the page of results to receive for multiple residence datasets.",
            "exclusiveMaximum": false,
            "exclusiveMinimum": false,
            "format": "double",
            "in": "query",
            "minimum": 0,
            "name": "page",
            "required": false,
            "type": "number"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/PostcodeToAddressResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "PostcodeToAddresses",
        "tags": [
          "Postcodes"
        ]
      }
    },
    "/udprn/{udprn}": {
      "get": {
        "deprecated": false,
        "description": "Returns an address identified via its Unique Delivery Point Reference \nNumber (UDPRN).\n\nYou may find it useful to store UDPRN information as it can be used to \nretrieve the most recent information for an address. It can also be used \nto test for a \"decommissioned\" address.\n\nUDPRNs are an eight digit unique numeric code (e.g. 25962203) for any \npremise on the Postcode Address File. It's essentially a unique identifier \nfor every address in the UK that Royal Mail has in its database.\n\n### Testing\n\nTo test your implementation of our API we have a range of test UDPRNs \nthat yield both successful and unsuccessful responses to your request. \nThey are the following\n\n- <code>0</code> Returns a successful UDPRN lookup response <code>2000</code>\n- <code>-1</code> Returns \"UDPRN not found\", error <code>4044</code>\n- <code>-2</code> Returns \"no lookups remaining\", error <code>4020</code>\n- <code>-3</code> Returns \"daily (or individual) lookup limit breached\", error <code>4021</code>\n\nTest requests will undergo usual authentication and restriction rules (\nindividual and daily lookup limits) to surface any problems you may have \nduring implementation. However, it will not count towards a postcode \nlookup on your key.\n\n### Pricing\n\nPer lookup charges apply. Empty responses are not charged.\n\n### Data Source\n\nRoyal Mail (Postcode Address File), Ordnance Survey (Code-Point Open)\n",
        "operationId": "UdprnByUdprnGet",
        "parameters": [
          {
            "description": "",
            "in": "path",
            "name": "udprn",
            "required": true,
            "type": "string"
          },
          {
            "description": "Only required if you are using a sublicensed key. This parameter will associate the request with your licensee",
            "in": "query",
            "name": "licensee",
            "required": false,
            "type": "string"
          },
          {
            "description": "Comma separated whitelist of address elements to return. E.g. `filter=line_1,line_2,line_3` returns only `line_1`, `line_2` and `line_3` address elements in your response",
            "in": "query",
            "name": "filter",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "LookupUDPRN",
        "tags": [
          "UDPRN"
        ]
      }
    },
    "/umprn/{umprn}": {
      "get": {
        "deprecated": false,
        "description": "UMPRNs are a unique numeric code for any Multiple Residence household on the optional Multiple Residence dataset.\n\n### Lookup a UMPRN\n\nReturns an address identified via its UMPRN.\n\n### Testing\n\nTo test your implementation of our API we have a range of test UMPRNs that yield both successful and unsuccessful responses to your request. They are the following:\n\nTo test your implementation of our API we have a range of test UMPRNs that yield both successful and unsuccessful responses to your request. They are the following\n\n- `0` Returns a successful UMPRN lookup response `2000`\n- `-1` Returns \"UMPRN not found\", error `4044`\n- `-2` Returns \"no lookups remaining\", error `4020`\n- `-3` Returns \"daily (or individual) lookup limit breached\", error `4021`\n\nTest requests will undergo usual authentication and restriction rules (individual and daily lookup limits) to surface any problems you may have during implementation. However, it will not count towards a postcode lookup on your key.\n\n### Pricing\n\nPer lookup charges apply. Empty responses are not charged.\n\n### Data Source\n\nRoyal Mail (Postcode Address File), Ordnance Survey (Code-Point Open).\n",
        "operationId": "UmprnByUmprnGet",
        "parameters": [
          {
            "description": "",
            "in": "path",
            "name": "umprn",
            "required": true,
            "type": "string"
          },
          {
            "description": "Only required if you are using a sublicensed key. This parameter will associate the request with your licensee",
            "in": "query",
            "name": "licensee",
            "required": false,
            "type": "string"
          },
          {
            "description": "Comma separated whitelist of address elements to return. E.g. `filter=line_1,line_2,line_3` returns only `line_1`, `line_2` and `line_3` address elements in your response",
            "in": "query",
            "name": "filter",
            "required": false,
            "type": "string"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "headers": {},
            "schema": {
              "$ref": "#/definitions/AddressLookupResponseSchema"
            }
          },
          "400": {
            "description": "Bad request",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "402": {
            "description": "Request failed",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "404": {
            "description": "Resource not found",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          },
          "503": {
            "description": "Rate limit exceeded",
            "schema": {}
          },
          "default": {
            "description": "Server error",
            "schema": {
              "$ref": "#/definitions/ErrorResponseSchema"
            }
          }
        },
        "security": [
          {
            "api_key": [],
            "user_token": []
          }
        ],
        "summary": "LookupUMPRN",
        "tags": [
          "UMPRN"
        ]
      }
    }
  },
  "produces": [
    "application/json"
  ],
  "schemes": [
    "https"
  ],
  "securityDefinitions": {
    "api_key": {
      "description": "",
      "in": "query",
      "name": "api_key",
      "type": "apiKey"
    },
    "user_token": {
      "description": "",
      "in": "query",
      "name": "user_token",
      "type": "apiKey"
    }
  },
  "swagger": "2.0",
  "tags": [
    {
      "name": "Postcodes"
    },
    {
      "name": "Addresses"
    },
    {
      "name": "Autocomplete"
    },
    {
      "name": "UDPRN"
    },
    {
      "name": "UMPRN"
    },
    {
      "name": "Keys"
    },
    {
      "name": "Licensees"
    }
  ]
}